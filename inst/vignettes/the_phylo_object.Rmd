---
title: "The 'phylo' object in R"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
output:
  html_document: default
  pdf_document: default
---

This markdown is an overview of the `"phylo"` object, an internal `R` object from the `ape` package that contains all informations to build a phylogenetic tree in `R`.
Here we will dissect a `"phylo"` object into its core components and see how they work together.
Note however that **most of the time, you don't need to tinker with the `"phylo"` object** if you read it or generated it using a function from the `ape` package.
This tutorial is mostly written for curious people or people developping packages using the `"phylo"` object.

## Glossary

Here are some definitions of the terms used below referring to phylogenetics:

 * tree: a phylogenetic tree (a non-cyclical conex graph);
 * node: an internal element in a tree connecting different elements (e.g. an ancestor and a descendant);
 * tip: a specific node on a tree which has no descendants (e.g. a species, a genus, an observation, etc...);
 * root: a specific node on a tree which has no ancestor (e.g. the first ancestor of the whole tree);

# The basic structure

## The essentials

Here is the very basic structure of a `"phylo"` object.
First let's create one:

```{r}
## A very basic tree in newick (A is related to B,
## A and B are related to C)
phy <- read.tree(text = "((A, B), C);")
```

This tree is in `"phylo"` format from `ape` and can be printed and plotted showing the tree's structure:

```{r}
## What class is the tree?
class(phy)
## Printing the tree
phy
## Plotting it:
plot(phy)
```

You can also visualise what's actually in it in `R` using the `str` function:

```{r}
## What's in it?
str(phy)
```

We can see that `phy` is actually a list of three elements (`$edge`, `$Nnode` and `$tip.label`) with two attributes (one being the class `"phylo"` - the other one we'll see later).

### `$edge`: the edges table

This is the essential core (and elegance!) of the `"phylo"` object, it's a table summarising the relation between each element in the tree.

```{r}
## The edge table
phy$edge
```

The edge table is always a matrix of 2 columns with integers.
The number of rows depends on the number of tips and nodes in the tree.
The way to read this table is that each row correspond to one edge and each column corresponds respectively to the ancestor (column 1) and the descendant (column 2).
For example here, the first edge is connecting element 4 to element 5.
The second edge, connects 5 to 1, the third: 5 to 2, and the fourth: 4 to 3.

Here is a way to visualise this with the elements in blue (nodes) or yellow (tips) and the edges in green:

```{r}
plot(phy, show.tip.label = FALSE)
edgelabels()
nodelabels()
tiplabels()
```

To make this clearer you can use this simple function to translate everything in something more human readable: {#edge.to.table}

```{r}
# @param phy a "phylo" object
# @returns a matrix with human readable information about the "phylo" edge table
edge.to.table <- function(phy) {
    edge_table <- phy$edge
    ## Renaming the columns
    colnames(edge_table) <- c("ancestor (from)", "descendant (to)")
    ## Replacing the elements where possible:
    ## Tips
    edge_table[match(1:Ntip(phy), edge_table[, 2]), 2] <- phy$tip.label
    ## Nodes
    if(!is.null(phy$node.label)) {
        ## Replace all nodes
        nodes <- phy$node.label
        counter <- 0
        while(length(nodes) > 0) {
            counter  <- counter + 1
            edge_table <- gsub(as.character(Ntip(phy)+counter), nodes[1], edge_table)
            nodes <- nodes[-1]
        }
    }
    ## Add the row names
    rownames(edge_table) <- paste0("edge", 1:Nedge(phy))
    return(edge_table)
}

## The edge table to be read by a human
edge.to.table(phy)
```

And we can visualise it like this:

```{r}
plot(phy, show.tip.label = FALSE)
edgelabels(rownames(edge.to.table(phy)))
nodelabels()
tiplabels(phy$tip.label)
```

If the tree had node labels (see [below](#nodelabels)), you could replace the node labels by specific names, for example 4 would be the root of the tree and 5 would be the ancestor of A and B.
Also note that the elements are named always in the following order:
  
  * The tips: from 1 to the number of tips (`1:Ntip(phy)`);
  * The first node (the root of the tree): the next integer (`Ntip(phy)+1`)
  * All the nodes: the number of tips + 1 (the root) to the total of elements (`(Ntip(phy)+1):(Ntip(phy)+Nnode(phy))`)

> Important! The order of the rows in the edge table matters: they should always be ordered in a nested traversal way from the root.
I.e. it starts from the root and then going into each sub-clade.
For example starting from the root (4) into the clade containing node 5 and tips 1 and 2, then going from the root to the next clade (that happens to be just tip 3 here). 

```{r}
## Making a different tree!
different_phy <- phy
different_phy$edge <- different_phy$edge[c(3,4,2,1), ]
plot(different_phy)
```

### `$Nnode`: the number of nodes

This should be a single `"integer"` or `"numeric"` value of the numeric of nodes in the tree.
A useful tip is that for any bifurcating tree, the number of nodes is equal to the number of tips minus 1.

### `$tip.label`: the tip names

This is simply a vector or a list of any elements referring to the tip names.
Usually this is a `"character"`, `"integer"` or `"numeric"` vector but it can also be `"list"` of these three types or even any other type (you can have a list of `"function"` for example).
The only restriction is that this vector or list should be of the same length of the numbers of tips.

## Other common aspects

### `$node.label`: names of the nodes {#nodelabels}

Another common aspect to `"phylo"` objects is to have node labels.
This is a vector of the length of the number of nodes in the tree from the tree to the tips.
In our example, our first node is the root and our second node the ancestor between A and B:

```{r}
## Adding node labels
phy$node.label <- c("root", "ancestor_AB")
```

This updates the printing of the `"phylo"` object:

```{r}
phy
```

But not the structure of the edge table (you can translate it though using the `edge.to.table` function [from above](#edge.to.table)):

```{r}
## Same edge table structure
phy$edge

## Here is it more human readable though:
edge.to.table(phy)
```

> Note that you can automatically name all nodes in a tree using the function `makeNodeLabel`.


### `$edge.length`: the length of each edge

In the example above, we've been just looking at the structure of the tree ignoring branch (edge) lengths.
You can add this information to `"phylo"` objects with the `$edge.length` that's a vector of `"numeric"` values for each edge (in our case 4 values):

```{r}
## Adding four edge lengths
phy$edge.length <- c(1.0, 2, 1.3, 1.4)
```

You can combine that with the "human readable" table from before:

```{r}
## All the information you need
cbind(as.data.frame(edge.to.table(phy)), "edge lengths" = phy$edge.length)
```

The tree will now look very different:

```{r}
## All the information you need
plot(phy, show.tip.label = FALSE)
edgelabels(phy$edge.length)
nodelabels(phy$node.label)
tiplabels(phy$tip.label)
## And adding a scale bar
## (by default in time units from the present)
axisPhylo()
```

## Other commonly aspects (not always necessary)

## `$root.time`

This aspect is very often used in packages dealing with palaeontological data, especially when then tree is not dealing with tips that are currently alive (e.g. a tree with only fossils).
This is commonly used in `Claddis`, `dispRity` or `paleotree`.
It allows to scale the age of the tree to some point in the past for example, for the exact same tree we have plotted above, we assume that the tip "A" is living in the present and everything else lives in the past (with the root of the tree 3 units of time ago - e.g. 3 million years ago).
But say tip A is actually 10 million years old, we can set the root of the tree to reflect that (and set it to 13 units of time ago):

```{r}
## Adding a root age
phy$root.time <- 13
## Plotting the tree (the topology did not change)
plot(phy)
## Adding the scale bar (the age is not much older)
axisPhylo()
```

## `"multiPhylo"`

This is a very useful additional class of `"phylo"` in `ape`.
It's basically a specific class name for a list that contains _only_ `"phylo"` objects.
It can then be passed to multiple functions in `ape` or other packages that can directly deal with lists of `"phylo"` objects.

```{r}
## Creating a list of trees
my_list_of_trees <- list(phy, read.tree(text = "((A, B), C);"))

## This is just a list containing our modified tree and our original one
my_list_of_trees

## Making it a multiPhylo object
class(my_list_of_trees) <- "multiPhylo"

## This is now a multiPhylo object containing 2 trees
my_list_of_trees
```

You can access each individual tree using subsetting.
For example `my_list_of_trees[[1]]` accesses the first tree, `my_list_of_trees[[2]]` the second; but `my_list_of_trees[1]` accesses a list of trees (`"multiPhylo"`) containing only the first tree.
If you are not familiar with subsetting in `R`, [read the following documentation](https://search.r-project.org/R/refmans/base/html/Extract.html).


<!-- 



# Modifying a `"phylo"` object



### Table conversion

```{r, eval = FALSE, echo = FALSE}
## Create the table from any phylo object
phylo.to.table <- function(tree) {
    ## Create the table
    edge_table <- data.frame(tree$edge)
    edge_table <- edge_table[,c(2,1)]
    colnames(edge_table) <- c("node", "parent")
    ## Add the edge.length
    if(!is.null(tree$edge.length)) {
        edge_table <- cbind(edge_table, tree$edge.length)
        colnames(edge_table)[3] <- c("length")

    }
    ## Convert the names
    if(!is.null(tree$tip.label)) {
        tip_matches <- which(edge_table[, "node"] %in% 1:length(tree$tip.label))
        edge_table[tip_matches, "node"] <- tree$tip.label[edge_table[tip_matches, "node"]]
    }
    if(!is.null(tree$node.label)) {
        ## Node (i.e. descendants)
        nodes <- as.integer(edge_table[, "node"])
        nodes[is.na(nodes)] <- 0
        node_matches <- which(nodes %in% (1:length(tree$node.label) + Ntip(tree)) )
        edge_table[node_matches, "node"] <- tree$node.label[nodes[node_matches]-Ntip(tree)]
        ## Parents (i.e. ancestors)
        parents <- as.integer(edge_table[, "parent"])
        node_matches <- which(parents %in% (1:length(tree$node.label) + Ntip(tree)) )
        edge_table[node_matches, "parent"] <- tree$node.label[parents[node_matches]-Ntip(tree)]
    }
    return(edge_table)
}

## Creates a phylo object from a table
table.to.phylo <- function(table) {
    ## Create the edge table
    edge <- table[, c("parent", "node")]
    ## Get the edge lengths
    if(any("length" %in% colnames(table))) {
        edge.length <- table[, "length"]
    } else {
        edge.length <- NULL
    }

    ## Get the number of nodes (half the number of edges for a bifurcating tree)
    Nnode <- (nrow(edge)/2)

    ## Convert the edge table into integers
    ## Detecting each elements
    tips  <- edge[(!edge[,2] %in% edge[,1]), 2] # tips are in the node column only
    nodes <- edge[(edge[,2] %in% edge[,1]), 2] # nodes are in both columns
    root  <- unique(edge[!(edge[,1] %in% edge[, 2]), 1]) # root is only in the parent column
    ## Get the elements integer value
    root_int <- length(tips)+1
    nodes_int <- paste0("node_temp_", 1:Nnode + root_int)
    tips_int <- 1:length(tips)

    ## Update the root as integer
    edge[,1] <- gsub(root, root_int, edge[,1])
    ## Update the nodes as integers
    recursive.gsub <- function(x, y, vector) {
        while(length(x) > 0) {
            vector <- gsub(x[1], y[1], vector)
            x <- x[-1]
            y <- y[-1]
        }
        return(vector)
    }
    edge <- apply(edge, 2, function(x, nodes, nodes_int) recursive.gsub(nodes, nodes_int, x), nodes, nodes_int)
    ## Update the tips as integers
    edge[,2] <- recursive.gsub(tips, tips_int, edge[,2])
    ## Recursively reorder the nodes (root must connect to root+1 and root+2, etc...)
    first_node <- max_node <- root_int
    while(length(grep("node_temp_", edge)) > 0) {
        ## Name the new nodes
        new_node_id <- 1:2 + max_node
        ## Find the descendants of the first node
        to_replace <- edge[grep(first_node, edge[,1]),2]
        ## Check if needs replacement
        needs_replacement <- grep("node_temp_", to_replace)
        if(length(needs_replacement) > 0) {
            to_replace <- to_replace[needs_replacement]
            new_node_id <- new_node_id[1:length(to_replace)]
            ## Replace in the table
            edge <- apply(edge, 2, function(x, to_replace, new_node_id) recursive.gsub(to_replace, new_node_id, x), to_replace, new_node_id)
        }
        ## Update next node to check
        first_node <- new_node_id[1]
        max_node <- max(new_node_id)
    }
    
    ## Get the tip labels
    tip.label <- tips
    node.label <- c(root,nodes)

    ## Format it as an integer matrix
    edge <- apply(edge, 2, as.integer)
    colnames(edge) <- NULL
    ## Sort them by root for convenience
    edge <- edge[order(edge[, 1]),]

    ## Make the list
    tree <- list(edge = edge, tip.label = tip.label, Nnode = Nnode, edge.length = edge.length, node.label = node.label)
    class(tree) <- "phylo"
    return(tree)
}


## Using your example data.frame
phylo_df <- data.frame(
  node   = c("t1", "t2", "t3", "t4", "t5", "A", "B", "C"),
  parent = c("A",  "A",  "B",  "C",  "C",  "B", "D", "D"),
  length = c(0.7, 0.08, 0.32, 0.24, 0.07, 0.91, 0.7, 0.95)
)

## Creating a phylo object
(my_tree <- table.to.phylo(phylo_df))


## Creating the table (you can ignore the coercion warning)
(my_table <- phylo.to.table(my_tree))
```

### Adding internal nodes


```{r, eval = FALSE, echo = FALSE}
#@param tree a phylo object
#@param element.IDs the numbers before and after the internal node
#@param edge.length the added edge length
add.internal.node <- function(tree, element.IDs, edge.length) {

    ## Find the edge in the edge table
    tree_edge <- tree$edge
    old_edge <- which(apply(tree_edge, 1, function(x, IDs) all(x == IDs), IDs = element.IDs))
    if(length(old_edge) == 0) {
        stop("edge not found")
    }

    ## Add the new edge
    tree_edge <- rbind(tree_edge[-old_edge, ], c(element.IDs[1], "new"), c("new", element.IDs[2]))

    ## Adding a new edge length
    if(!is.null(tree$edge.length)) {
        new_edge_lengths <- c(tree$edge.length, edge.length)
    }

    ## Re-ordering node labels for the new edge table
    ## (element IDs need to be ordered in phylo objects)
    #1- name the new node (should be ID+1)
    tree_edge <- gsub("new", paste0("new", element.IDs[1]+1), tree_edge)
    #2- update all the nodes after ID+1
    update.nodes <- function(x, ID) {
        if(!is.na(as.integer(x))) {
            ## Is not NA so it's a node (update the value if it's higher than the ID)
            return(ifelse(as.integer(x) > ID, as.integer(x)+1, x))
        } else {
            ## Is NA so it's the new node (leave it be for now)
            return(x)
        }
    }
    ## Update all nodes
    tree_edge <- apply(tree_edge, c(1,2), update.nodes, ID = element.IDs[1])
    ## Remove the "new" bit and make everything integers again
    tree_edge <- gsub("new", "", tree_edge)
    tree_edge <- apply(tree_edge, c(1,2), as.integer)

    ## Update the tree with the new node and the new edge.length
    tree$edge <- tree_edge
    if(!is.null(tree$edge.length)) {
        tree$edge.length <- new_edge_lengths
    }
    tree$Nnode <- tree$Nnode+1

    return(tree)
}


## Generate a similar tree as in the example
set.seed(20)
tree <- rtree(4)
plot(tree)
axisPhylo(); nodelabels(); tiplabels(); edgelabels()

## Adding a node between elements 7 (node) and 4 (tip)
test <- add.internal.node(tree, element.IDs = c(7, 4), edge.length = 0.1)
plot(test)
axisPhylo(); nodelabels(); tiplabels(); edgelabels()

```


## Adding cherries

```{rr, eval = FALSE, echo = FALSE}
## Function for adding a cherry to a tree where a single tip was before
add.cherry <- function(tree, tip, new.tips) {

    ## Find the edge leading to the tip
    tip_id <- match(tip, tree$tip.label)

    ## Create the new cherry
    tree_to_add <- ape::stree(length(c(tip, new.tips)))

    ## Naming the tips
    tree_to_add$tip.label <- c(tip, new.tips)

    ## Add 0 branch length
    tree_to_add$edge.length <- rep(0, Nedge(tree_to_add))

    ## Binding both trees
    return(bind.tree(tree, tree_to_add, where = tip_id))
}

## Adding a new sister taxon to t6 (with a 0 branch length)
new_tree <- add.cherry(orig_tree, tip = "t6", new.tips = "t6a")
plot(new_tree)

## Adding a bunch of sister taxa to t8
new_tree <- add.cherry(orig_tree, tip = "t8", new.tips = c("t8a", "t8b", "t8c"))
plot(new_tree)

## List of four tips to modify
tips_to_modify <- list("t1", "t3", "t6", "t8")

## List of tips to add to these four tips
tips_to_add <- list("t1a", c("t3.1", "t3.2"), "t6a", c("t8a", "t8b", "t8c"))

## Adding the tips all together
new_tree <- orig_tree
for(one_tip in seq_along(tips_to_modify)) {
    new_tree <- add.cherry(new_tree, tip = tips_to_modify[[one_tip]], new.tips = tips_to_add[[one_tip]])
}
```



# Optional arguments to `"phylo"`
 -->