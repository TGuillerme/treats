---
title: "treats workshop"
author: "Thomas Guillerme"
date: "`r Sys.Date()`"
output:
  html_document:
    fig_width: 12
    fig_height: 6
---

Most of the information about the workshop comes from the [`treats` manual](https://tguillerme.github.io/treats).
You can also always find more documentation about the functions used here using the `R` inbuilt manual by typing `?function.name`.

#### `R` level

In this workshop I will assume you are already familiar with basic `R`. The basic notions that I'll assume you know are:

 * What is a package (e.g. `ape` or `dispRity`)
 * What is an object (e.g. `this_object <- 1`)
 * What is an object's class (e.g. the class `"matrix"` or `"phylo"`)
 * What is a function (e.g. the function `mean(c(1,2))`)
 * How to access function manuals (e.g. `?mean`)

Let's get into it.
First we'll want to download and install the package:

```{r, eval = FALSE}
install.package("treats")
library(treats)
```

# Intro:

What ca we do with `treats`?

 * Simulate trees and traits for illustration (toy model, teaching) 
 * Simulate trees and traits as a null model for analysis
 * Whatever you want
!
TODO: show illustration examples

# The bare basics

```{r}
library(treats)
set.seed(1)
```
## Growing a tree

For the very basics here we're going to see how to grow a tree with the minimum number of options.
`treats` is designed to grow trees easily but not with to many default options this is so to encourage users to know what they're doing _at least a minimum_.

### `stop.rule`

So what do we need? To grow a tree you need to fix a rule of when the simulation should stop:
This is a hard coded rule for stopping the growth of a tree, this can be the number of species (living or fossil) or a certain time of the simulation. Here when I mean time, I mean how long the simulation runs for in arbitrary time units (e.g. million of years, etc...).

This is passed to the `stop.rule` argument that is a named list containing integers or numeric values.
For example:

```{r}
## Stopping when reaching 200 species
stop_200_sp <- list(max.taxa = 200)
## Stopping when reaching 4 time units
stop_4_time <- list(max.time = 4)
```

You can then feed these stop rules to the treats function and let the magic happen:

```{r}
## Create a tree with 200 taxa
tree_200_sp <- treats(stop.rule = stop_200_sp)
## Creating a tree with 4 time units
tree_4_time <- treats(stop.rule = stop_4_time)
```

This results in two different trees (`"phylo"` objects) that you can easily visualise with the excellent `"ape"` package:

```{r}
## What's in these objects?
tree_200_sp
tree_4_time

## Displaying the trees
op <- par(mfrow = c(1,2))
plot(tree_200_sp, main = "Stop at 200 tips") ; axisPhylo()
plot(tree_4_time, main = "Stop at 4 time units") ; axisPhylo()
par(op)
```

So the trees here have roughly the same age but a very different shape, we'll get back to that in a moment.
One other thing to note for this stopping rule, is that you can stack them: for example, you can ask the simulation to stop when it reaches 200 species _or_ 4 time units.


```{r}
## Multiple rules
my_stop_rules <- list(max.taxa = 200, max.time = 4)
## Simulating one tree with these rules
my_tree <- treats(stop.rule = my_stop_rules)
## Displaying the resulting tree
plot(my_tree) ; axisPhylo()
```

### `bd.params`

As mentioned above, we can have vastly different trees depending on the simulation random seed.
You can of course always modify that by modifying the seed.
But a more interesting method is to try to control the actual speciation parameter.
This is also called the birth or $\lambda$ parameter.
You can find details on how the speciation and the extinction parameters are used in the birth-death equations in the [`treats` manual](http://tguillerme.github.io/treats.html) (or anywhere else where there's info about birth-death algorithms) so I'm not gonna go in the details here.
Basically, the bigger the speciation parameter, the shorter the tree branches (the bushier the tree).

You can set this parameter using the `make.bd.params` function:

```{r}
set.seed(1)
## Creating a small birth parameter
speciation_0.5 <- make.bd.params(speciation = 0.5)
## Creating a big birth parameter (1 is the default by the way)
speciation_1.0 <- make.bd.params(speciation = 1.0)

## Simulating the trees
my_tree_small <- treats(stop.rule = my_stop_rules,
                        bd.params = speciation_0.5)
my_tree_big   <- treats(stop.rule = my_stop_rules,
                        bd.params = speciation_1.0)
## Displaying the trees
op <- par(mfrow = c(1,2))
plot(my_tree_small, main = "Speciation = 0.5") ; axisPhylo()
plot(my_tree_big, main = "Speciation = 1.0") ; axisPhylo()
par(op)
```

By the way, throughout the pipeline in the package you can check what's in the object you create.
For example, `speciation_0.5` is a `"treats"` and `"bd.params"` object that contains info about the parameters:

```{r}
## What is this?
class(speciation_0.5)
## What's in it?
speciation_0.5
```

This allows you to always double check what's in the objects you create!

### The death parameter!

Note that this object contained also an extinction parameter (set to 0 by default).
This allows to introduce extinction events in your trees!
The bigger this parameter, the more fossils in your tree.

```{r}
## Creating a small death parameter
extinction_0.1 <- make.bd.params(extinction = 0.1,
                                 speciation = 1)
## Creating a big death parameter
## (note speciation = 1 is the default)
extinction_0.5 <- make.bd.params(extinction = 0.5)

## Simulating the trees
set.seed(1) ## Putting the seed here ensures both trees grow the same way
few_fossils  <- treats(stop.rule = my_stop_rules,
                       bd.params = extinction_0.1)
set.seed(1)
many_fossils <- treats(stop.rule = my_stop_rules,
                       bd.params = extinction_0.5)

## Displaying the trees
op <- par(mfrow = c(1,2))
plot(few_fossils,  main = "Extinction = 0.1", show.tip.label = FALSE) ; axisPhylo()
plot(many_fossils, main = "Extinction = 0.5", show.tip.label = FALSE) ; axisPhylo()
par(op)
```

OK but what's actually happening in the algorithm here? Again there's many ways to illustrate or define the birth-death process (e.g. [wikipedia](https://en.wikipedia.org/wiki/Birth%E2%80%93death_process)) but we can have a look at a simple illustration of each step [here](http://tguillerme.github.io/treats_01.html).

> Note that speciation and extinction are fixed values here. But they can also be distributions! For example `make.bd.params(speciation = runif)` creates a `bd.params` object with a speciation always randomly drawn between 0 and 1. You can also link this parameter to the extinction parameter (for example for keep speciation always greater than extinction). Have a look at `?make.bd.params` for more details

### More simulation options for `treats`

Just before we get in the more interesting bits, I want to highlight some useful options to deal with stochasticity in `treats`.
In fact, sometimes (often?) your trees can "die" before reaching the stop value, especially if the speciation and extinction parameters are close to each other numerically

```{r} 
## Creating some dangerous parameters
dangerous_params <- make.bd.params(speciation = 1,
                                   extinction = 0.9)
```
```{r, eval = FALSE} 
## Simulating a tree that "dies" (returns an error)
set.seed(2)
dead_tree <- treats(stop.rule = my_stop_rules,
                    bd.params = dangerous_params)
```

This outputs an error message! Aaaah!
But fear not, you can handle this error message differently depending on what you need:

 * you can either set it to null rather than and error (giving you `NULL` rather than an error) using the `null.error = 100` option:

```{r} 
## Simulating a tree that "dies" (returns NULL)
set.seed(2)
dead_tree <- treats(stop.rule  = my_stop_rules,
                    bd.params  = dangerous_params,
                    null.error = TRUE)
dead_tree # is NULL
```

 * or you can "brute force" it by keeping trying to generate a tree until it works (or you loose) patience using the `null.error = n` option (where *n* is the number of trials you're happy to wait for:

```{r} 
## Simulating a tree that "dies" (try and try again!)
set.seed(2)
dead_tree <- treats(stop.rule  = my_stop_rules,
                    bd.params  = dangerous_params,
                    null.error = 100,  ## Try up to 100 times!
                    verbose    = TRUE) ## Visualise the trials
dead_tree # is a tree!
```

Finally, you can also create tree distributions by using the option `replicates = n` that will generate _n_ trees.

## Adding a trait

Now this is all nice a well but not very different from other great `R` packages that allow you to grow a birth-death tree.
If anything it's maybe even just more cumbersome! 
But of course, in `treats` you can also do the traits simulation part!
To do that we're going to use the `make.traits` function that will create a `"treats"` and `"traits"` object.

First we need to choose a trait generation process.
This process should be a `function` that intakes the arguments `x0` (the value of the trait in at it's last node) and `edge.length` (the amount of evolutionary time since last node).

For example we can create a Brownian Motion (BM) that is process that draws a random value from a normal distribution centered on some value (`x0`) and with a standard deviation that's relative to the evolutionary time spend (`edge.length`).
By default it's good practice to set the `edge.length` argument to a specific value (say 1).

```{r}
## Creating a simple BM process
my.BM.process <- function(x0, edge.length = 1) {
    return(rnorm(n = 1, mean = x0, sd = sqrt(edge.length)))
}
```

You can then feed this process to `make.traits` and set some specific parameters (e.g. the starting value) or check if it works and visualise it:

```{r}
## Creating the trait object with the BM process
## and a starting value of 0
my_trait <- make.traits(process = my.BM.process,
                        start   = 0)
## What is the trait?
class(my_trait)
## What's in it?
my_trait ## Note the process name is A (you can change that)
## Visualising what the process would look over time
plot(my_trait, main = "What does the process look like over time?")
```

> Note that you can of course use much more complex processes (e.g. multidimensional, with correlation, etc...). You can find some inbuilt processes by looking at the documentation for `?trait.process`.

Once you're happy with your process you can simply feed it to `treats` with the other arguments we've covered before:

```{r}
## Generating a tree and a trait
tree_and_trait <- treats(stop.rule  = my_stop_rules,
                         bd.params  = extinction_0.5,
                         traits     = my_trait,
                         null.error = 100,
                         verbose    = TRUE)
```

The resulting object is now a `"treats"` object (not a `"phylo"` as previously) that contains two main elements: the tree (a `"phylo"` object) and the data (a code `"matrix"`).

```{r}
## What is it?
class(tree_and_trait)
## What's in it?
tree_and_trait
## The tree:
tree_and_trait$tree
## The data
head(tree_and_trait$data)
```

You can again also visualise both together using our faithful `plot` function:

```{r}
## Wow!
plot(tree_and_trait, main = "A tree with a trait")
```

And that's it! We've simulated a tree and a trait at the same time.
The whole point of this package is of course the modularity where you can play around and choose different tree parameters and different traits.

In the next part we'll even see how we can complexify all that by making all the birth-death process and the traits interact.
Because yes, in this example so far the trait is just "mapped" on the tree: in other words, although both are simulated at the same time, the traits here are not influencing the tree generation.

### Bonus: map.traits

This means that you can also just "map" any trait on a tree that you already have.
For example, here we're going to map this BM trait on the bird orders example tree from `ape` using the `map.traits` function:

```{r}
## Loading the bird.orders tree
data(bird.orders)

## map the trait on the tree
## (i.e. simulate the trait using the tree topology)
my_bird_BM <- map.traits(traits = my_trait, tree = bird.orders)

## Show the results
op <- par(mfrow = c(1,2))
plot(bird.orders, main = "A tree with no traits")
plot(my_bird_BM, main = "A tree with a trait")
par(op)
```

The resulting object is a `"treats"` one so you can also just quickly generate just the data using `map.traits(traits = my_trait, tree = bird.orders)$data`.

### Bonus: save.steps

Note that here we've been generating trait values only at nodes and tips.
In some cases, you might be interested to see you trait values generated constantly through time rather than just during speciation and extinction events. For example simulating trait values every _x_ amount of time.
You can do this using the `save.steps` in `treats` for example to generate the data every 0.2 time units:

```{r}
## Generating a tree and a trait every 0.2 time steps
continuous_trait <- treats(stop.rule  = my_stop_rules,
                           bd.params  = extinction_0.5,
                           traits     = my_trait,
                           save.steps = 0.2,
                           null.error = 100,
                           verbose    = TRUE)
## Visualise the tree and trait
plot(continuous_trait)
```

Of course though, the bigger the tree and the traits, the slower the algorithm (and the more RAM eaten)!

## Adding modifiers!

But let's get back to fun modular stuff: one of the advantages of the `treats` package is that you can modify _all_ steps of the process.


Show the birth death process in action [here](http://tguillerme.github.io/treats_01.html)

Simulate a tree where the trait influences the growing

You can also add events, but we'll see this later!

# Generating some null models

## K-Pg example

## Modeling extinction event

## Comparing both

# Bonus: some plotting options!