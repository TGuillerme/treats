--- 
title: "treats manual"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output: bookdown::gitbook
documentclass: book
bibliography: [../references.bib]
link-citations: yes
github-repo: TGuillerme/treats
description: "treats R package manual"
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# `treats`: trees and traits simulations.

Simultaneously simulate phylogenetic trees and traits (and the interaction between them).

The core of this package is based on the [`diversitree` birth-death algorithm](https://github.com/cran/diversitree/blob/master/R/simulate-bd.R).

## What is `treats`?

Bib is studying the evolution of mammalian disparity (i.e. diversity of shapes) across the Cretaceous-Palaeogene mass extinction event (K-Pg - 66 million years ago).
They observe a decrease of morphological disparity after the extinction event followed by a sharp increase of disparity.
However Bib is also prudent and wants to test whether their observed pattern is just an artifact of the data or actually showing some effect of the K-Pg extinction on mammalian evolution.
First they need to check whether changes in disparity can actually be discernables due to an extinction event (i.e. if an extinction event happens, would it be possible to detect a change in disparity)?
Second they want to know whether these changes are due to the mass extinction event being selective or not (i.e. the mass extinction favored some traits).

The [illustrative example](#kpgexample) section actually shows how do implement this example in `treats` in details. 

Of course, this is just an example of when to use `treats`.
Simulating trees and traits can also be useful for:

 * Provide a baseline/null model to compare to an observed one.
 * Testing evolutionary hypotheses.
 * Exploring statistics properties (i.e. can the disparity metric X capture changes in Y).
 * Easily generating illustrative/simplified evolutionary history examples.
 * Teaching simplified macro-evolutionary theory (e.g. the birth-death model).

Note that for approaching these points individually (or some aspects of it), there are some very good R packages that simulate birth-death trees (e.g. [TreeSim](https://github.com/tanja819/TreeSim)) or simulate traits (disparity) and diversity jointly (e.g. [RPANDA](https://github.com/cran/RPANDA) or [PETER](https://github.com/PuttickMacroevolution/PETER)).
We strongly advise you look at these packages first as they might be more appropriate for your needs.

`treats` is a highly modular and user-friendly package that contains the simulations functionality of all these packages: it allows you to simulate disparity and diversity jointly with a vast array of options that can be easily modified by users.
For example, you can easily generate any type of process to generate a trait (BM, OU, something else, etc.) in multiple dependent or independent dimensions through `"traits"` objects.
You can then specify how the traits should affect disparity through `"modifiers"` objects. 
And finally you can create events (like mass extinctions) through `"events"` objects.
These objects and how to modify them will be detailed throughout this manual.
Finally we are putting an emphasis in the development of this package on the speed and reliability of the functions.

### Modular?

Because there is an infinite number of ways you might want to generate disparity and diversity (different traits, different modifiers and different events), the `treats` package is designed to make all these parts easy to code separately and integrate in the `treats` core functions.
This allows you to simulate finely-tuned multidimensional data for your specific project!

## Who is this manual for?

This manual explains how `treats` works in as much details as possible and aims to give you the keys to design your own diversity and disparity simulations.

The first section `Getting started` is aimed for people with a `R` beginner level:

 * you know what a package is - and how to install it;
 * you know what a function is - and what arguments are;
 * you have already (vaguely) heard that there are different types of objects in R - like matrices (`"matrix"`) or trees (`"phylo"`);
 * and you have already looked for documentation online.
 
The sections after that are a bit more advanced and require the following level:

 * you have already created functions before;
 * you know how to subset elements of a list - i.e. you understand the `list$element` syntax;
 * you are aware that both `TRUE == 1` and `FALSE == 0` are `TRUE`;
 * you have heard that the objects in R have classes and that it sometimes matters - for example you know that R can differentiate between `as.numeric(1)` and `as.integer(1)`;
 * you owe part of your work to Stack Overflow.


## Installing and running the package

You can install this package easily, directly from the GitHub:
<!-- TG: I do intend to release it on CRAN later on -->

```{r, eval = FALSE}
## Checking if devtools is already installed
if(!require(devtools)) install.packages("devtools")

## Installing the latest version directly from GitHub
devtools::install_github("TGuillerme/treats")
```

```{r, eval = FALSE, echo = FALSE, message = FALSE}
## Loading the package and setting up the start seed.
library(treats)
```

## Help

If you need help with the package, hopefully the following manual will be useful.
However, if you have suggestions or comments on on what has already been developed or will be developed, please send me an email (<guillert@tcd.ie>) or if you are a GitHub user, directly create an issue on the [GitHub page](https://github.com/TGuillerme/treats).
Doing so will not only help you but also other users as it will help improve this manual and the package!


## How does `treats` work?

Basically, the `treats` function takes your `traits`, `modifiers` and `events` objects to simulate disparity and diversity.
You will find more details about how these objects (`traits`, `modifiers` and `events`) work in the rest of the tutorial but here is a graphical representation of how `treats` works:

![Schematic summary of the `treats` package architecture](treats_structure.png)

## The birth-death algorithm {#bdalgorithm} 

> If you want to get your hands dirty, you can go straight to the [getting started section](#gettingstarted), this following section just describes the process in pseudo-code.

The `treats` algorithm is based on a modular version of the birth-death process algorithm.
The birth-death model is a continuous Markov process (i.e. a continuous random process where future events depend only on the present, and not on past events) which is well defined mathematically and [commonly used in evolutionary biology](https://lukejharmon.github.io/pcm/chapter10_birthdeath/#section-10.2-the-birth-death-model) but also in [many other fields](https://en.wikipedia.org/wiki/Birth%E2%80%93death_process).

The algorithm used in `treats` allows modularity of this process and is based on the following steps (the text in `courier font` is for the name of the process in the algorithm):

 0. **Starting the process**: this step is non-modular and creates a random tree with one tip, one node and one branch connecting both. This step is used to optimise the rest of the algorithm in terms of speed and memory management. The node, tip and branch resulting from this step are discarded at the end of the simulations.
 1. **Selecting a lineage** (`selecting`): this step selects a tip that is currently not extinct. In a standard birth-death process this is done randomly, however in `treats` this can be modified based on the birth-death parameters, the currently available lineages and potential trait values. *For example, it is possible to put a higher probability for selecting a lineage that is closely related to a lineage that recently went extinct and has a positive trait value.*
 Then go to step 2.
 2. **Growing the tree** (`waiting`): this step grows the tree by a certain amount. It does so by adding the same amount of branch length to all the non-extinct lineages. In an exact birth-death process, this is done by drawing a random value from an exponential distribution with a rate of $$\text{number of living lineages} \times (\text{speciation} + \text{extinction parameters})$$. In `treats`, this can be modified based on the birth-death parameters, the currently available lineages and potential trait values. *For example, it is possible to increase branch length by the ratio of living/extinct fossils and a random number drawn from the range of current trait values.*
 If the total tree length is less than the required tree length, go to step 3. Else go to step 6.
 3. **Simulating traits** [optional]\(`traits`): this step allows you to simulate a trait value for the selected lineage from step 1. This is typically not part of a standard birth-death process and is handled via the `traits` option in `treats` (see the [`make.traits`](#maketraits) chapter for more details).
 Then go to step 4.
 4. **Speciating** (`speciating`): in this step, the selected lineage from step 1 has the option of speciating or going extinct. In a standard birth-death process, this happens by randomly drawing a value between 0 and 1 as a way to trigger speciation relative to the birth-death parameters:
```
if
    randomly drawn number is smaller or equal to speciation/(speciation + extinction)
then
    do speciate
else
    go extinct
```
 Again, in `treats`, this process can be modified based on the birth-death parameters, the currently available lineages and potential trait values. *For example, the lineage can only speciate if its trait value is positive, regardless of whether speciation or extinction have been triggered*. 
 Then go to step 5.
 5. If the number of lineages is less than required number of lineages, then go to step 1. Else go to step 6.
 6. The simulation stops because it has reached the required amount of lineages and/or time (i.e. branch length).

<!--chapter:end:index.Rmd-->

---
title: "Getting start"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
bibliography: [../references.bib]
output:
  html_document: default
  pdf_document: default
---

```{r, echo = FALSE}
library(treats)
set.seed(4242)
```

# Getting started {#gettingstarted}

## The simplest analysis: simulating diversity only

One of the simplest things to do with the `treats` package is to simulate a birth-death tree.
For that you can use the function `treats` and specify your stopping rule.
The stopping rule simply tells the birth-death process to stop whenever it reaches one of these three conditions:

 * `"max.taxa"   = n` stop when `n` taxa are generated;
 * `"max.living" = n` stop when there are `n` co-occuring taxa of the same age (i.e. "living" taxa);
 * `"max.time"   = n` stop when the simulated tree is `n` units of age old (these units are arbitrary);

For example, we might want to generate a birth-death tree with 20 taxa:

```{r}
## Setting a stopping rule to reach a maximum of 20 taxa
my_stop_rule <- list(max.taxa = 20)
```

We can now run the simulations using:

```{r}
## Running the birth-death simulation
my_tree <- treats(stop.rule = my_stop_rule)
```

> Note that here we could have specified more than one stopping rule, for example, we might want to run a simulation and stop it if it *either* reaches 10 taxa *or* the age 2 using `stop.rule = list(max.time = 2, max.taxa = 10)`. The simulation will then stop when either of these conditions are met.

The resulting object is a classic `"phylo"` object that you can plot like so:

```{r}
## The tree object
my_tree
## Plotting it
plot(my_tree)
```

### Changing the birth-death parameters

People familiar with the [birth-death models](https://lukejharmon.github.io/pcm/chapter10_birthdeath/) might have noticed that we did not specify two important things here: the speciation parameter (sometimes called "lambda" or "birth") and the extinction parameter (sometimes called "mu", "death" or "background extinction").
By default `treats` runs a pure birth model (speciation is set to 1 and extinction to 0).
However, you can easily change that by specifying your own birth-death parameters:

```{r}
## my birth-death parameters
my_params <- list(speciation = 1,
                  extinction = 1/3)
```

> You can find more information about setting up more complex birth-death parameters [in this section](#makebdparams). 

You can then run the same birth-death tree simulation with extinction:

```{r}
## Generating a birth-death tree with extinctions:
my_tree <- treats(bd.params = my_params, stop.rule = my_stop_rule)
## Visualising the new tree
plot(my_tree)
```

## Slightly more complex: simulating disparity and diversity

Chances are that you are using `treats` because you also want to simulate traits (disparity) along with your diversity (otherwise, we suggest using the [`TreeSim`](https://github.com/tanja819/TreeSim/) package that provides many more birth-death models).
Simulating traits is not much more complicated in `treats`: you'll simply need to create a `"traits"` object using the `make.traits` function.
These objects can have increasing complexity (see the rest of this tutorial) but we will keep it simple here.

`"traits"` objects contain one or more processes which are the ways to generate the trait.
The most common of these processes is the [Brownian Motion](https://en.wikipedia.org/wiki/Brownian_motion) model.
This is used by default with the `make.traits` function:

```{r}
## Creating the traits object
my_trait <- make.traits()
```

This trait object can be simply printed (to see what's in it) or plotted (to see what the process looks like in the absence of a phylogeny):

```{r}
## Which process is in here?
my_trait
## What does it look like?
plot(my_trait)
```

By default, this trait is called "A".
This is not a really good name but you'll see more about specifying trait names later on.
If this is what the process should look like (theoretically) you can then add its `"traits"` object to our previous `treats` function to generate the tree and the traits:

```{r}
## Simulate disparity and diversity
my_data <- treats(bd.params = my_params,
                stop.rule = my_stop_rule,
                traits    = my_trait)
```

Et voilà! We now have a simple disparity and diversity simulation.
We can see what's in the results by simply printing it or plotting it:

```{r}
## What's in there
my_data
## Plotting the disparity and diversity
plot(my_data)
```

You can then extract the components you need for your specific analysis like so:

```{r}
## Extracting the tree 
the_generated_tree <- my_data$tree
# Note that this is a "phylo" object
class(the_generated_tree)

## Extracting the data 
the_generated_data <- my_data$data
# Note that this is a "matrix" or "array"
class(the_generated_data)
```

You can find much more about how to design trait objects in the [`make.traits` section](#maketraits).

### `"treats"` objects

`treats` will output either just a tree (class `"phylo"`) if no traits were generated or a `"treats"` object that contains both a `$tree` (`"phylo"`) and a `$data` (`"matrix"`) component.
Note that this `"treats"` class is generalised to most outputs of the package functions.
This allows for a smoother handeling of the objects outputs such as summarising the content of a `make.bd.params` output or visualising a trait output from `make.traits`.

## Slightly more complex again: simulating linked disparity and diversity 

The example above is still pretty simple and easily done through a variety of `R` packages: here the trait and the tree are simulated at the same time but only the tree is simulating the trait (i.e. the trait value at a tip is affected by its ancestor and the branch length leading to it) but not the other way around (the trait value does not affect the tree).
It is possible to add this aspect using `"modifiers"` objects.
`"modifiers"` are similar to `"traits"` in that you specify what should go in there and then feed it to your simulation.

`"modifiers"` affect two key steps of the birth-death process: the calculation of the waiting time (i.e. the component generating branch lengths) and the triggering of speciation or extinction events.
These events can be modified using `condition` and `modify` functions.
In other words, when reaching a certain condition specified by a `condition` function, the birth-death process will modify either the branch length or the speciation (or extinction) probability by applying a `modify` function.

You can use the function `make.modifiers` to design a specific `"modifiers"` object.
By default, this function generates a `"modifiers"` object that affects branch length and speciation in the following way:

 * branch length is a randomly drawn number from an exponential distribution with a rate equal to the current number of taxa multiplied by the sum of the speciation and extinction rates.
 * speciation is triggered if a randomly drawn number (from a (0,1) uniform distribution) is smaller than the ratio between the speciation rate and the sum of the speciation and extinction rates. If that random number is greater, the lineage goes extinct.

Note that these are defaults for a birth-death tree and were already applied in the examples above without specifying a `"modifiers"` object:

```{r}
## Make a default modifiers object
default_modifiers <- make.modifiers()
## What's in it?
default_modifiers
```

This will not do anything to our simulations compared to the previous trait and tree simulation but we can provide our `"modifiers"` object to the `treats` function:

```{r}
## Setting the simulation parameters
extinction_02 <- list(extinction = 0.2)
living_20     <- list(max.living = 20)
BM_trait      <- make.traits()

# Set random seed so we get the same results
set.seed(1)

## Simulate disparity and diversity
default_data <- treats(bd.params = extinction_02,
                     stop.rule = living_20,
                     traits    = BM_trait,
                     modifiers = default_modifiers)
default_data
```

Note however, that the printing information is now updated to state that you've added a `"modifiers"` object (even though it's the same as the default).
In this specific case the `modifiers` object is not necessary as it is doing nothing different than when using the default one (i.e. when no `modifiers` is provided).

For more interesting simulations however, you can provide modifiers that actually modify the birth-death process.
We can create one for example that makes species go extinct if their ancestor has a negative trait value.
For that we need to create a `"modifiers"` object that modifies the `speciation` process with a specific condition and a specific modification when that condition is met.
For a speciation to occur (and a species to not go extinct), the algorithm draws a random value _x_ between 0 and 1 and if the value is smaller than the speciation parameter divided by the speciation + extinction parameter, the lineage speciates ($x < (\lambda \div (\lambda + \mu))$), else it goes extinct.
_x_ is a random value that simulates some stochasticity in the evolutionary simulation.
At every step of the simulation, a different random value _x_ is drawn making sure that the resulting speciation or extinction is not predictable. 

However, we can create a modifier that introduces less randomness (or a different level of randomness) by forcing the lineage to go extinct every time a specific condition is met, e.g. if the lineage trait value is negative.
This can be done for example by not randomly generating the value _x_ but giving it a fixed value of say 1 so that the estimation of the speciation function $x < (\lambda \div (\lambda + \mu))$ is always met.
In other words, if the lineage's trait value is negative, make sure that _x_ is equal to 1, so that the speciation condition $x < (\lambda \div\ (\lambda + \mu))$ is never met.

First we need to create a `condition` function to trigger this (non) speciation event.
We can do that by specifying our `condition` function (here the `going.extinct` function) to apply our modification.
For that we can use the `parent.traits` utility function that is optimised for accessing traits in the birth-death process (but you can of course write your own).
This function takes the `trait.values` and `parent.lineage` arguments, two arguments that you can leave named as they are to facilitate `treats`' understanding of what you want to assess:

```{r}
## Triggering a modification only if the ancestor trait is negative
negative.ancestor <- function(trait.values, lineage) {
    return(all(parent.traits(trait.values, lineage) < 0))
}
```

> Note that we use the function `all` here to evaluate all traits: i.e. if the data has more than one trait we trigger the modification only if all the trait values are negative. 

Then we create the modification function.
This function must take the argument `x` and, in our case, returns the same value no matter what: `1` so that speciation never happens when the `negative.ancestor` function is triggered.

```{r}
## Always go extinct
going.extinct <- function(x) return(1)
```

This `going.extinct` function is to be contrasted with the normal modifier for selecting the value `x` which is `runif(1)` (drawing a random value between 0 and 1).
We can then provide these two functions (the condition `negative.ancestor` and how to modify the speciation event when this condition is met `going.extinct`).
If you are an advances `treats` user, you can design your own `speciation` function but if you just want to use a normal `speciation` function, you can use the default one from `treats` called `speciation`.

```{r}
## Making a modifier for species to go extinct if
## their ancestor's trait value is (or are) negative
negatives_extinct <- make.modifiers(
            ## If the following condition is met...
            condition = negative.ancestor, # Does the lineage have an ancestor with negative trait values?
            ## Then apply the following modifier...
            modify = going.extinct, # The species goes extinct
            ## To the the speciation process.
            speciation = speciation) # Here the speciation() process is default

## What's in it?
negatives_extinct
```

Note that the `make.modifiers` function tests whether the input is compatible with `treats` by default so unless you have an error message, your `modifiers` will work!
We can now simulate our tree and traits with our modifier: species will go extinct if their ancestor has a negative trait value:

```{r}
set.seed(1)
## Simulate disparity and diversity
modified_data <- treats(bd.params = extinction_02,
                        stop.rule = living_20,
                        traits    = BM_trait,
                        modifiers = negatives_extinct)
modified_data
```

We can now compare the two trees and their trait values.
Note that we've used the same starting seed for both trees so the only thing differing between them is the `"modifier"` object which leads to very different trees!

```{r, fig.height = 6, fig.width = 12}
par(mfrow = c(1,2))
plot(default_data, main = "default results")
plot(modified_data, main = "results with the modifier")
```

You can find much more about how to design modifiers in the [`make.modifiers` section](#makemodifiers).


## An illustrative example: mammals disparity through the K-Pg extinction {#kpgexample}

Bib is studying the evolution of mammalian disparity (i.e. diversity of shapes) across the Cretaceous-Palaeogene mass extinction event (K-Pg - 66 million years ago).

They use a dataset from @beckancient2014 that is a discrete morphological space containing the ordination of the around 400 morphological characters for 50 species and estimated for their 49 descendants into an ordinated shapespace of 99 elements and 97 dimensions.

```{r}
library(dispRity)
## Loading the mammalian morphological example data
data(BeckLee_mat99)

## This is what the dataset looks like
head(BeckLee_mat99)[1:5, 1:5]
```

And a tree showing the relation between these species through time:

```{r}
## The phylogenetic tree
data(BeckLee_tree)

## And what the tree looks like
plot(BeckLee_tree, cex = 0.8)
axisPhylo()
abline(v = BeckLee_tree$root.time - 66, col = "red")
```

They measure the disparity as the sum of variances as a proxy for changes in the traitspace size (@moms) with some bootstrapping to create some confidence intervals around that curve.

```{r}
## Making continuous time series
time_series <- chrono.subsets(data = BeckLee_mat99,
                              tree = BeckLee_tree,
                              method = "continuous", model = "proximity",
                              time = seq(from = 101, to = 41, by = -5))
## Calculating disparity
change_in_size <- dispRity(boot.matrix(time_series), metric = c(sum, variances))
plot(change_in_size)
abline(v = 8, col = "red")
```

> For more info about `chrono.subsets` and the `dispRity` package, you can have a look at the [`dispRity` manual](http://tguillerme.github.io/dispRity.html).

Looking at this curve, Bib wants to know whether disparity increased as a response to the K-Pg mass extinction or not.
To do this, they need to check whether changes in disparity can actually be detected due to an extinction event (e.g. if an extinction event happens, does that change disparity curves?).
As a subsidiary question, they want to know whether the pattern is more likely due to a selective or random extinction event.

### Simulating trees and traits using the observed parameters

The first step is to simulate the observed tree.
We can do that by using crude parameters from the observed tree:

```{r}
## Extracting the crude parameters
(est_params <- crude.bd.est(BeckLee_tree, method = "count"))
## These parameters are the observed speciation and extinction rate per million years.

## Setting the stopping rule (stop after reaching 50 taxa)
stop_rule <- list(max.taxa = 50)

## Simulating just a birth-death tree with these parameters to check
set.seed(1)
test_tree <- treats(bd.params  = est_params,
                    stop.rule  = stop_rule,
                    null.error = 100)
plot(ladderize(test_tree), cex = 0.8)
axisPhylo()
```

> Note that because of the high extinction to speciation ratio, the tree simulations can often fail before reaching the stop rule (i.e. all lineages go extinct before reaching 50 taxa). To avoid getting stuck in there, we use the option `null.error = 100` to rerun the simulations up to 100 times before obtaining a tree that did not went fully extinct. Also note that using such parameters make the simulations run slowlier but ensure the requested results are always achieved.

We now have a way to simulate a topology close to the observed one. We can simulate a list of topologies by replicating this function X amounts of time to get a distribution of trees:

```{r, eval = FALSE, message = FALSE}
## Generating 50 trees
tree_distribution <- treats(bd.params  = est_params,
                            stop.rule  = stop_rule,
                            null.error = 100,
                            replicates = 50)
```

Of course, here our objective is to also simulate some trait values to measure disparity under some simulated scenario.
We can do that be adding a `"traits"` object to the `treats` function.
Here we will use a default [Brownian Motion](https://en.wikipedia.org/wiki/Brownian_motion) to simulate our trait.

```{r}
## Creating a trait in 97 dimensions.
my_traits <- make.traits(process = BM.process, n = ncol(BeckLee_mat99))
```

> Note that there are many more options on how to simulate your trait such as using correlation, different processes, etc... See details in the [make traits section](#maketraits).

```{r, message = FALSE}
## Simulate the tree and traits
sim_data <- treats(traits     = my_traits,
                   bd.params  = est_params,
                   stop.rule  = stop_rule,
                   null.error = 100)
```

We can visualise the resulting tree using the `plot` function and visualising the different traits using the `trait` option in `plot`:

```{r}
## Plotting the results (first trait)
plot(sim_data, trait = 1)
```

Of course, here we want to simulate a distribution of trees and traits:

```{r, message = FALSE}
## Simulate the tree and traits
sim_data <- treats(traits     = my_traits,
                   bd.params  = est_params,
                   stop.rule  = stop_rule,
                   null.error = 100,
                   replicates = 50)
```

Et voila! We now have a distribution of 50 trees and 50 datasets from which we can calculate disparity.
We can directly pass the results to the `dispRity` package pipeline using the `dispRitreats` function:

```{r, message = FALSE, warning=FALSE}
## Calculate the dispRity for all the simulations
simulated_disparity <- dispRitreats(sim_data,
                                    method = "continuous",
                                    model  = "proximity",
                                    time   = 10,
                                    metric = c(sum, variances),
                                    scale.trees = TRUE)
par(mfrow = c(1,2))
plot(simulated_disparity, main = "simulated disparity")
plot(change_in_size, main = "observed disparity")
```


We can see that both simulated and observed disparity curves are different.
From there one could already reasonably propose that the observe disparity does not entirely follows our parametrised scenario (constant speciation and extinction and BM trait evolution).

However, we can complexify our scenario to introduce the effect of mass extinction event.
We can simulate two alternative scenarios:
 * one where we create a random extinction event after having simulated half of the species (25) where we remove 75% of species;
 * and a second one where we remove all the species with negative values.
This allows us to simulate two contrasted scenarios to see whether using our observed dataset it would be possible to detect changes in disparity due to mass extinctions.

To do so, we need to create two mass extinction `"event"` objects:

```{r}
## Creating a random mass extinction
random_extinction <- make.events(target = "taxa",
                                 condition = taxa.condition(25, condition = `>=`),
                                 modification = random.extinction(0.75))
## Creating an extinction that removes species with negative trait values
negative_extinction <- make.events(target = "taxa",
                                   condition = taxa.condition(25, condition = `>=`),
                                   modification = trait.extinction(x = 0, condition = `>=`))
```

We can then feed these two extinction events to our previous simulations

```{r, message = FALSE}
## Simulate the tree and traits with a random extinction event
sim_rand_extinction <- treats(
                   traits     = my_traits,
                   bd.params  = est_params,
                   stop.rule  = stop_rule,
                   events     = random_extinction,
                   null.error = 100,
                   replicates = 50)

## Simulate the tree and traits with a random extinction event
sim_trait_extinction <- treats(
                   traits     = my_traits,
                   bd.params  = est_params,
                   stop.rule  = stop_rule,
                   events     = negative_extinction,
                   null.error = 100,
                   replicates = 50)

## Visualising the difference between both scenarios
par(mfrow = c(1,2))
plot(sim_rand_extinction[[1]], main = "Random extinction")
plot(sim_trait_extinction[[1]], main = "Negative extinction")
```

We can then measure the disparity from these scenarios and compare them to our observed ones

```{r}
## Simulate the tree and traits with a random extinction event
sim_rand_extinction <- treats(
                   traits     = my_traits,
                   bd.params  = est_params,
                   stop.rule  = stop_rule,
                   events     = random_extinction,
                   null.error = 100,
                   replicates = 50)

## Simulate the tree and traits with a random extinction event
sim_trait_extinction <- treats(
                   traits     = my_traits,
                   bd.params  = est_params,
                   stop.rule  = stop_rule,
                   events     = negative_extinction,
                   null.error = 100,
                   replicates = 50)

## Visualising the difference between both scenarios
par(mfrow = c(1,2))
plot(sim_rand_extinction[[1]], main = "Random extinction")
plot(sim_trait_extinction[[1]], main = "Negative extinction")
```

Interestingly, with all our parameters used here and our specific disparity metric we cannot detect the effect of a mass extinction.




<!--chapter:end:01_getting_started.Rmd-->

---
title: "`make.traits`"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
bibliography: [../references.bib]
output:
  html_document: default
  pdf_document: default
---

# Simulating traits {#maketraits}

```{r, echo = FALSE}
library(treats)
set.seed(123)
```

In `treats`, traits are simulating by providing a `traits` object to the `traits` argument.
This object is generated using `make.traits`.
In `treats` a trait designate any coherent character of any number of dimensions which may or may not be independent of other traits.
For example, it can be a uni-dimensional variable uncorrelated to other traits or a multi-dimensional one with different amounts of correlation.

![`make.traits`: The main inputs are (1) the `process`, one or more functions to describe the trait(s) as a function of previous state (`x0`) and the branch length (`edge.length`), (2) `n` the number of dimensions of the trait and (3) the starting value `start`.](make.traits.png)

### Quick overview

function | arguments | input | what does it do
---------|-----------|-------|----------------
`make.traits` | process* | a function | simulates the trait (see below)
`make.traits` | n | a numeric value | the number of dimensions
`make.traits` | start | one or more numeric values | the starting values for each dimensions
`make.traits` | process.args | ... | anything to be passed to `process` (see below)
`make.traits` | trait.names | a character string | the name(s) of the trait(s)
`make.traits` | add | a `treats` object | another trait generated by `make.traits`
`make.traits` | update | a `treats` object | another trait generated by `make.traits`
`make.traits` | test | logical | whether to test the validity of the trait
`make.traits` | background | a `treats` object | another trait generated by `make.traits` (to run in the background)
---------|-----------|-------|----------------
`process` | x0 | a numeric value | the value of the previous trait
`process` | edge.length | a numeric value | the branch length value
`process` | ... | ... | any other argument to be handled by the process

\* non-optional arguments

## The process (`process`)

The function `make.traits` allows you to design the process of a trait or a set of traits.
Here, the process of a trait designates the rules needed to generate the trait through time while simulating a phylogeny.
This process can depend on the previous state in the tree (i.e. the trait of the ancestor) and the branch length to the descendant.
One classic example is the [Brownian motion process (or Weiner process)](https://en.wikipedia.org/wiki/Brownian_motion).
Note that it _can_ depend on both the ancestor and the branch length but does _not necessarily need to_, i.e. the process can be based only on the previous state or only on branch length or on neither.

### The syntax (how to code a process?)

Trait processes in `treats` are functions that must always take the following arguments by default.

 * `x0`: the previous trait value(s)
 * `edge.length`: the branch length
 * `...`: a placeholder for any extra arguments

For example, the following function would be a valid process that always generate the _true_ trait value: 42!.
In this example, the process is not dependent on either the previous state (`x0`) or the branch length (`edge.length`).

```{r}
## A valid (but useless?) process
valid.process <- function(x0 = 0, edge.length = 1, ...) {
    return(42)
}
```

> Note that in this function definition the arguments `x0` and `edge.length` have a default value of `0` and `1` respectively. In practice, these arguments are effectively set to the correct values in the `treats` internal function (i.e. whatever `x0` and `edge.length` are at that specific time of the process) but providing a default can help speed up the algorithms (specifically all the internal checks).

On the other hand, the following process (a unidimensional Brownian motion) is incorrect (it's missing `edge.length` and `...`):

```{r}
## A wrongly formatted process
invalid.process <- function(x0 = 0) {
    return(rnorm(1, mean = x0))
}
```

This will not work in `make.traits` (see below).

### Using a `"process"` in `treats`

You can design your own process as a function, as long as it has a valid syntax.
Alternatively, the `treats` package has several inbuilt processes, namely a multidimensional Brownian motion (`BM.process`) or a multidimensional Ornstein-Uhlenbeck process (`OU.process`).
You can find the list of implemented processes by looking at the `?trait.process` manual page in `R`.

Once a process is chosen, you can feed it into the `make.traits` function:

```{r}
## Creating a trait object
my_trait_object <- make.traits(process = BM.process)
```

This creates `"treats"` `"traits"` objects that you can print and visualise using the `plot` function:

```{r}
## The class of the object
class(my_trait_object)
## What's in it?
my_trait_object
## What does the process looks like
plot(my_trait_object)
```

Note that you can see the multiple options for plotting the trait process by looking at `?plot.treats` manual. Furthermore, you can look at what's actually in the object using this specific syntax (this applies to every object handled by the `treats` package):


```{r}
## What's actually in that object?
print.treats(my_trait_object, all = TRUE)
```

As traits can get more and more complex, the automatic printing of its summary allows for a easier display of what's in the `"traits"` object.

Note that it is possible to make `"traits"` objects with multiple traits and multiple processes (that can be the same or different for each trait):

```{r}
## Four traits: two BM, one OU and one normal non process
four_traits <- make.traits(process = c(BM.process,
                                       BM.process,
                                       OU.process,
                                       no.process))
four_traits
```

You can visualise them individually using the `trait` argument in `plot.treats`:

```{r}
## Plot options (4 plots in one window)
par(mfrow = c(2,2))
plot(four_traits, trait = 1)
plot(four_traits, trait = 2)
plot(four_traits, trait = 3)
plot(four_traits, trait = 4)
par(mfrow = c(1,1))
```

## The number of traits `n` and the starting values `start`

Two further important arguments are `n` the number of traits per process and `start` the starting values for all traits.
By default they are set to `n = 1` and `start = 0`.
This means that `make.traits` will assume that your processes are always unidimensional by default and that they always start with the value `0`.
It is possible however, to change these values.

For example you can use the following to create a three dimensional Brownian motion with each dimension starting with the value `1`:

```{r}
## Multidimensional Brownian motion
make.traits(BM.process, n = 3, start = 1)
```

Or the following with each dimensions starting with different values (respectively `1`, `2` and `3`):

```{r}
## Multidimensional Brownian motion
make.traits(BM.process, n = 3, start = c(1,2,3))
```

Note that the number of traits are applied for each process by default.
However, you can apply different number of traits for different processes:

```{r}
## two 3D processes (BM and OU)
make.traits(c(BM.process, OU.process), n = 3)
## one 1D processes (BM) and one 4D process (OU)
make.traits(c(BM.process, OU.process), n = c(1, 4))
```

And starting values are distributed for all the traits or for the traits one by one:

```{r}
## two 3D processes (BM and OU) starting with 1
make.traits(c(BM.process, OU.process), n = 3, start = 1)
## two 3D processes (BM and OU) starting with values 1 to 6
make.traits(c(BM.process, OU.process), n = 3, start = 1:6)
## two 3D processes (BM and OU) with the two first ones starting
## with 1 and the 4 other ones with the default (0)
make.traits(c(BM.process, OU.process), n = 3, start = c(1,1))
```

### What is a trait in `treats`?

Because it would be impossible to accommodate all definitions of a trait in `treats` we chose an arbitrary one: a trait is whatever you define as a trait!
A trait can be uni-dimensional as the measurement of a feature of an organism (e.g. leaf surface, femur length, etc.) but can also be a multi-dimensional description of a feature, for example in 3D geometric morphometric context, a trait could be defined as "position of landmark X" (which will be a trait with three dimensions, _x_, _y_ and _z_) or in ecology, the location of a plant can be expressed as latitude and longitude coordinates.
In `treats`, the **process** corresponds to this trait definition (e.g. a process can be of n-dimensions and represents one organisms feature) and the **traits** represents the number of dimensions in total. 
So in the examples above, this is how the following traits are interpreted by `treats`:

```{r, eval = FALSE}
## Three traits with one process:
make.traits(BM.process, n = 3, start = c(1,2,3))
## Six traits with two processes:
make.traits(c(BM.process, OU.process), n = 3)
## Five traits with two processes
make.traits(c(BM.process, OU.process), n = c(1, 4))
```

## Multidimensional traits and correlations

As shown in the example above, a trait can be made multidimensional by using the `n` argument specifically passed to a `process`.
However, in this case, traits are simulated independently of each other.
It is possible to include correlation by designing a multidimensional trait `process` directly generating the correlation between within the dimensions of the process.
Alternatively, the inbuilt `BM.process` and `OU.process` can intake a correlation matrix to simulate traits independtly but with a correlation coefficient (see [this illustration with an event](#EG_change_correlation)).

## Extra argument for the processes with `process.args`

You can also feed extra arguments to your process(es) functions. 
For example, the inbuilt process `no.process` (that is just a number generator not based on the previous value `x0` or the branch length) can take a specific random number generator as a function:

```{r}
## no process trait using the normal distribution (default)
make.traits(no.process, process.args = list(fun = rnorm))
## no process trait using the uniform distribution
## bounded between 1 and 100
make.traits(no.process, process.args = list(fun = runif, min = 1, max = 100))
```

You can also add multiple extra arguments for multiple processes giving them as a list.

```{r}
## Two traits with no process:one normal and one uniform (1,100)
make.traits(process = c(no.process, no.process),
            process.args = list(list(fun = rnorm),
                                list(fun = runif, min = 1, max = 100)))
```

If one process does not need extra argument you must still give it an extra `NULL` process argument:

```{r}
## Three traits with no process:
## one default, one lognormal and one uniform (1,100)
make.traits(process      = c(no.process, no.process, no.process),
            process.args = list(## Extra arguments for the first process (none)
                                list(NULL),
                                ## Extra arguments for the second process
                                list(fun = rlnorm),
                                ## Extra arguments for the third process
                                list(fun = runif, min = 1, max = 100)))
```

## Naming the traits with `trait.names`

As traits become more and more complex, it can be useful to give clearer names to each process.
This is easily done using the `trait.names` argument that attributes one name per process:

```{r}
## A simple trait with a proper name
simple_trait <- make.traits(trait.names = "1D Brownian Motion")
simple_trait
```

This becomes more useful if we use the complex example above:

```{r}
## Three named traits with no process:
## one default, one lognormal and one uniform (1,100)
make.traits(process      = c(no.process, no.process, no.process),
            process.args = list(## Extra arguments for the first process (none)
                                list(NULL),
                                ## Extra arguments for the second process
                                list(fun = rlnorm),
                                ## Extra arguments for the third process
                                list(fun = runif, min = 1, max = 100)),
            ## Naming each trait
            trait.names  = c("Normal", "LogNormal", "Uniform(1,100)"))
```


## Combining multiple traits with `add`

You can also add traits to already existing trait objects using the simple `add` option.
This option just takes a `"treats"` `"traits"` object and the additional process(es) will be added to it. 
For example:

```{r}
## Creating a simple default Brownian motion
one_process <- make.traits(trait.names = "BM")

## Creating a new trait (a 3D OU.process)
## and adding the previous one
two_processes <- make.traits(OU.process, n = 3, add = one_process,
                             trait.names = "3D OU")

## Only one process
one_process

## The two processes
two_processes
```

## Using a background trait

`traits` objects also allow a background trait to be used when traits are simulated ([step 3 here](#bdalgorithm)).
This allows traits to be simulated for _all_ tips whenever a trait is generated for one tip.
This can be useful for keeping track of trait values along the simulation (_cf_ just at bifurcating nodes).
The `background` argument takes any output from the `make.traits` function in a nested way:

```{r}
## Generating a default BM trait:
BM_trait <- make.traits()
## Generating an OU trait with a background BM trait
my_trait <- make.traits(process = OU.process, background = BM_trait) 
```

Note that technically you can nest as many background traits as you want (e.g. `make.traits(background = make.traits(background = make.traits(...)))` is valid).
However, you should always make sure that the background trait has the same dimensions as the main trait.
When using a trait with background, your tree will have internal singleton nodes (i.e. nodes linking to one ancestor and only one descendant).
You can remove these nodes using the [`drop.things` function](#dropthings).

```{r}
set.seed(1)
## Generating a pure birth tree with the background trait
tree_bkg <- treats(stop.rule = list(max.taxa = 20),
                 traits = my_trait)
## This tree has many internal singleton nodes
plot(tree_bkg)
```

## Saving trait values at different time steps

You can also simulate a tree by generating traits at specific time steps with the `save.steps` option in `treats`.
This will apply the `traits` object to all lineages currently alive at the required time steps.
These time steps can be either regular by providing a single numeric value; e.g. `save.steps = 0.1` will take a snapshot of the trait values every 0.1 units of time, or specific, by providing a specific set of values; e.g. `save.steps = c(1, 1.2, 3)` will take a snapshot of the trait values at the required time steps.

```{r}
set.seed(123)
## Generating a birth-death tree with a BM trait and saving steps at specific times
tree_steps <- treats(stop.rule  = list(max.time = 3),
                   bd.params  = list(speciation = 1, extinction = 0.1),
                   traits     = make.traits(),
                   save.steps = c(1/3, 1, 2))
## This also creates internal singleton nodes
plot(tree_steps)
abline(v = 3 - c(1/3, 1, 2), lwd = 0.5, col = "grey")
```

## Traits implemented in `treats`

If you don't want to design your own trait process, you can use one of the following trait processes that are currently implemented in `treats`. You can find more information about their many options using their specific manuals in R or the generic `?trait.process`:

 * `BM.process`: this is the well known [Brownian motion process](https://en.wikipedia.org/wiki/Brownian_motion).

```{r, echo = FALSE}
plot(make.traits(process = BM.process), main = "The Brownian motion")
```

 * `OU.process`: this is the equally famous [Ornstein–Uhlenbeck process](https://en.wikipedia.org/wiki/Ornstein%E2%80%93Uhlenbeck_process).

```{r, echo = FALSE}
plot(make.traits(process = OU.process), main = "The Ornstein–Uhlenbeck process")
```

 * `no.process`: this process has... no process. In other words, this is a non time dependent process; the simulated value does not depends on the ancestors' value nor the branch length. It's basically a place holder for a random sampling function like `rnorm` (default), `runif`, `rlnorm`, etc.


```{r, echo = FALSE}
plot(make.traits(process = no.process, process.args = list(fun = runif)), main = "No process using runif\n(yes, it \"looks\" like an OU!)")
```

 * `multi.peak.process`: this process is a modified version of the `OU.process` that can take multiple local long-term mean values. The default OU process has one long-term mean towards which the values are drawn with the alpha parameter (the elastic band). The single long-term mean is usually 0. However, with this `multi.peak.process` we can set multiple values towards which values can be attracted with the same alpha parameter.

```{r, echo = FALSE}
plot(make.traits(multi.peak.process, process.args = list(peaks = c(1, 5, 10))), main = "A multi-peak (OU) process\nwith peaks (optima) at 1, 5 and 10")
```

 * `repulsion.process`: this is a modified version of the `BM.process` where instead of accumulating gradually through time, new trait values are more likely to be different to the traits of their ancestor following a `repulsion` parameter.

```{r, echo = FALSE}
plot(make.traits(repulsion.process, process.args = list(repulsion = 5)), main = "A repulsion process\nwith a repulsion parameter of 5")
```

 * `discrete.process`: this one generates discrete trait values based on a transition matrix (you can use the utility function `transition.matrix` to generate one).

```{r, echo = FALSE}
## Generating a stepwise transition matrix for 3 states (with an overal random transition rate)
stepwise_matrix <- transition.matrix(type = "stepwise", states = 3)
## Generatin and plotting the the trait
plot(make.traits(discrete.process, process.args = list(transitions = stepwise_matrix)))
```

Of course here the plotting of a discrete trait is not that informative...

## Testing the traits with `test`

**This bit is still in development.**
We highly suggest leaving `test = TRUE` so that `make.traits` returns an error if a process or its additional arguments (`process.args`) are not formatted correctly.
`make.traits` will send an error if the trait cannot be directly passed to `treats`.
However, in some specific cases (again, probably mainly for development and debugging) it could be useful to skip the tests using `test = FALSE`.

## Mapping traits on a tree: `map.traits`

Although `make.traits` is mainly designed for `treats` simulations, i.e. simulating both the trees AND the traits at the same time, it is possible to use an already simulated or estimated tree and generating one or more traits on it using the `map.traits` function. This function takes the trait input as a `"traits"` object (from `make.traits`) and a tree topology with branch length. Note that you can also use `"traits"` objects with multiple or multi-dimensional traits as well as multiple phylogenies (`"multiPhylo"`).

```{r}
## Simulating a random tree with branch length
my_tree <- rtree(20)

## Creating three different traits objects:
## A Brownian Motion
bm_process <- make.traits(process = BM.process)
## An Ornstein-Uhlenbeck process
ou_process <- make.traits(process = OU.process)
## No process (just randomly drawing values from a normal distribution)
no_process <- make.traits(process = no.process)

## Mapping the three traits on the phylogeny
bm_traits <- map.traits(bm_process, my_tree)
ou_traits <- map.traits(ou_process, my_tree)
no_traits <- map.traits(no_process, my_tree)

## Plotting the topology and the different traits
par(mfrow = c(2,2))
plot(my_tree, main = "Base topology")
plot(bm_traits, main = "Mapped BM")
plot(ou_traits, main = "Mapped OU")
plot(no_traits, main = "Mapped normal trait")
```

## Templates for making your very own process

As detailed above, any process of your own design will work as long as it is a function that takes at least the arguments `x0` and `edge.length`.
You can be imaginative and creative when designing your own process but here are two detailed example functions for a unidimensional Brownian Motion and Ornstein-Uhlenbeck process that you can use for a start (or not).
Remember it is good practice for `treats` processes to set all the arguments with default values (just in case).

> Note that the functions below are not equal to the already implemented `BM.process` and `OU.process` but an easier to edit version that you can use as a template:

### A simple Brownian Motion process template

```{r}
## A simple Brownian motion process
my.BM.process <- function(x0 = 0, edge.length = 1, sd = 1, ...) {
    ## Drawing a random number from a normal distribution
    ## with x0 as the and a given standard deviation
    ## and depending on branch (edge) length
    result <- rnorm(n = 1, mean = x0, sd = sqrt(sd^2 * edge.length))

    ## Return the number
    return(result)
}
```

### A simple Ornstein-Uhlenbeck process template

```{r}
## A simple Ornstein-Uhlenbeck motion process
my.OU.process <- function(x0 = 0, edge.length = 1, var = 1, alpha = 1, ...) {
    ## Calculate the mean based on alpha
    mean <- x0 * exp(-alpha)
    ## Calculate the standard deviation based on alpha and the variance
    sd <- sqrt(var/(2 * alpha) * (1 - exp(-2 * alpha)))
    ## Draw a random number from a normal distribution
    ## using this mean and standard deviation
    ## and depending on branch (edge) length
    result <- rnorm(n = 1, mean = mean, sd = sqrt(sd^2 * edge.length))

    ## Return the number
    return(result)
}
```




<!--chapter:end:02_make.traits.Rmd-->

---
title: "`make.modifiers`"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
bibliography: [../references.bib]
output:
  html_document: default
  pdf_document: default
---

# Modifying the birth-death process {#makemodifiers}

```{r, echo = FALSE}
library(treats)
set.seed(123)
```

`"modifiers"` have a similar structure than `"traits"` where you can design an object with increasing complexity, starting with the simplest modifiers that doesn't modify anything (using the default arguments):

```{r}
## Making a default modifier (no modification)
my_default_modifiers <- make.modifiers()
my_default_modifiers
```

Similarly to `"traits"` objects, `"modifiers"` are also printed by default using `print.treats`.
You can see details about what's actually in the object using `print.treats(my_default_modifiers, all = TRUE)`.
However, contrary to `"traits"`, you cannot plot `"modifiers"`.


![`make.modifiers`: The three main inputs to make modifiers are functions to modify the `branch.length` (waiting) process controlling the "growth" of the tree; the `selection` (selecting) process controlling the selection of the tip on which to apply speciation or extinction; and the `speciation` (speciating) process controlling whether the select tip goes extinct or speciates. The allowed arguments are detailed [here](#allowarguments).](make.modifiers.png)

### Quick overview

function | arguments | input | what does it do
---------|-----------|-------|----------------
`make.modifiers` | branch.length | a function | generating branch length (see below)
`make.modifiers` | selection | a function | selecting a lineage (see below)
`make.modifiers` | speciation | a function | choosing between speciation and extinction (see below)
`make.modifiers` | condition | a function | a function that affects the condition of when to trigger the functions above (see below)
`make.modifiers` | modify | a function | a function that modifies the value of the trigger value generated when the `condition` is met (see below)
`make.modifiers` | add | a `treats` object | another modifier generated by `make.modifiers`
`make.modifiers` | update | a `treats` object | another modifier generated by `make.modifiers`
`make.modifiers` | test | logical | whether to test the validity of the modifier
---------|-----------|-------|----------------
`branch.length`, `selection`, `speciation`, `condition` | bd.params | a `treats` object generated by `make.bd.params` | usually handled internally (contains the either the birth-death values or their distribution)
... | lineage | a named "lineage" list | usually handled internally (contains the current state of the simulations)
... | trait.values | a matrix | usually handled internally (contains the current generated traits of the simulations)

## The default modifier (how the process is working)

The modifiers modify the core of the birth-death process as implemented in `treats`.
By default, the birth-death process in `treats` uses this modifier:

```{r}
## What is actually in the default modifier?
print(make.modifiers(), all = TRUE)
```

This contains a lot of information, much of it is actually not useful for using the modular aspects of `treats` at a high user level, i.e. unless you want to code very specific things, you won't need most of the information. The essentials are these three functions in the elements named `"waiting$fun"`, `"selecting$fun"` and `"speciating$fun"`: 

 1. `"waiting$fun"` is the branch length function (defined in detail below) which returns a randomly drawn number from an exponential distribution with the rate of the number of taxa multiplied by the speciation and extinction rate: $n \times (\lambda + \mu)$ (here is uses the extra function `sum` for internal modularity reasons). **This function is responsible for the growth of the length/age of the tree**

```{r, eval = FALSE}
rexp(1, sum(lineage$n * (bd.params$speciation + bd.params$extinction)))
```
 With `lineage$n` being the number of lineages and `bd.params$speciation` and `bd.params$extinction` the speciation and extinction parameters (these specific terms are defined in detail below).

 2. `"selecting$fun"` is the selection function (defined in detail below) which, after the waiting time defined above returns a randomly selected lineage (a tip) among the existing ones. **This function is responsible for the branch selection**.

```{r, eval = FALSE}
sample(lineage$n, 1)
```

 3. `"speciating$fun"` is the speciation function (defined in detail below) which randomly draws a number (`runif(1)`) and depending on the speciation and extinction parameters makes the selected lineage (from 2.) speciate (`TRUE`) or go extinct (`FALSE`). **This function is responsible for the speciation or extinction of species**.

```{r, eval = FALSE}
runif(1) < (bd.params$speciation/(bd.params$speciation + bd.params$extinction))
```

We will have a look at all these aspects below in more detail which should make things clearer (but you can always refer to the default here for information).

## The branch length function (`branch.length`)

The first argument in `"modifiers"` is the branch length function (`branch.length`) this is the function that will be executed in `treats` to generate branch lengths.
Note that in the `treats` algorithm, branch length is not generated _directly_ but as the result of the waiting time.
In other words, the `branch.length` function just affects waiting time for all taxa present at any time in the simulation.
These taxa can then either go extinct (stopping the "growth" of its branch length) or survive (continuing the "growth").

By default, branch length (or waiting/growth) is a randomly drawn number from an exponential distribution with the rate of the number of taxa multiplied by the speciation and extinction rate: $n \times (\lambda + \mu)$ (where $n$ is the number of taxa currently present in the simulation, $\lambda$ and $\mu$ are respectively the speciation and extinction rates).
This default function is simply called `branch.length` in `treats` and can be used as a modifier as follows:

```{r}
## Specifying the default modifier
default_modifiers <- make.modifiers(branch.length = branch.length)

## Setting some parameters for generating trees
bd_params <- list(extinction = 0)
stop_rule <- list(max.living = 20)

## Generating a tree with the default branch length parameter
set.seed(0)
default_tree <- treats(bd.params = bd_params,
                     stop.rule = stop_rule,
                     modifiers = default_modifiers)
```

Of course, the point of the modularity here is that you can provide your own function for generating branch length.
For example, we might be interested in what our tree would look like if we use a simple constant branch length generation (instead of randomly drawing it from an exponential distribution).
We can do so by declaring our own `branch.length` function and adding it to a `"modifiers"` object. 

```{r}
## A constant branch length generator
## (note that the output must be numeric, not integer)
constant.brlen <- function() {
    return(as.numeric(1))
}

## Creating the modifiers object
constant_modifier <- make.modifiers(branch.length = constant.brlen)

## Generating a new tree with this modifier
set.seed(0)
modified_tree <- treats(bd.params = bd_params,
                      stop.rule = stop_rule,
                      modifiers = constant_modifier)
``` 

And we can visualise the difference between both resulting trees:

```{r}
par(mfrow = c(1,2))
plot(default_tree,  main = "Default modifier")
plot(modified_tree, main = "Constant branch length\nmodifier")
par(mfrow = c(1,1))
```

It is of course possible to use more complex branch length modifiers that take different conditions and specific modification rather than simply always outputing a value of one.

### The modifier arguments {#allowarguments}

You can create a function for `branch.length`, `selection` and `speciation` that involve any of the following arguments:

  * `bd.params`: a named list containing `"numeric"` values that contains the birth-death parameters (at least `"speciation"` and `"extinction"`);
  * `lineage`: a named list containing the lineage data (see below).
  * `trait.values`: a `"matrix"` containing `"numeric"` values with the trait names as column names and the lineage ID as row numbers (you can use it with the function `parent.traits` to access the trait of the previous node for example).
  * `modify.fun`: a `"list"` of named `"function"` (usually passed through `condition` and `modify`).

The `lineage` list contains the following elements (missing elements are allowed):
 
 * `lineage$parents`: an `"integer"` vector: the list of parent lineages;
 * `lineage$livings`: an `"integer"` vector: the list of lineages still not extinct;
 * `lineage$drawn`: a single `"integer"`: the ID of the selected lineage; this must be a number in `1:lineage$n`;
 * `lineage$current`: a single `"integer"`: the selected lineage (is equal to `lineage$livings[lineage$drawn]`);
 * `lineage$n`: a single `"integer"`: the current number of non extinct lineage (is equal to `length(lineage$livings))`;
 * `lineage$split`: a `"logical"` vector: the list of splits for each lineage (`TRUE`), the number of total tips is equal to `sum(!lineage$split)`.

In general, unless you know what you're doing, you can ignore most arguments for specific modifiers since they are handled automatically within the `treats` function.
Therefore any argument can be left undeclared or missing and is always handled internally. For example, if you did not declare `lineage$n` as a function argument but are using `lineage$n` in the function, `lineage$n` will be detected and treated as a current argument automatically as set accordingly within the birth-death process (e.g. `lineage$n` will be set to the current number of taxa every iteration of the process).

For example, we can create a function that increases branch length proportional to the number of species "alive" at each time of the simulation in a discrete way, i.e. for discrete numbers of taxa, the branch length increases by jumps (ten fold) every five taxa:

```{r}
## A more complex binned.branch.length function
increasing.brlen <- function(bd.params, lineage) {

    ## Setting the cumulated birth and death
    birth_death <- bd.params$speciation + bd.params$extinction

    ## Returning branch lengths depending on different number of taxa
    if(lineage$n <= 5) {
        return(1    * rexp(1, sum(5 * birth_death)))
    }
    if(lineage$n <= 10) {
        return(10   * rexp(1, sum(10 * birth_death)))   
    }
    if(lineage$n <= 15) {
        return(100  * rexp(1, sum(15 * birth_death)))      
    }
    if(lineage$n <= 20) {
        return(1000 * rexp(1, sum(20 * birth_death)))
    } else {
        return(1000 * rexp(1, sum(lineage$n * birth_death)))
    }
}
```

We can then create it as a `"modifiers"` object and run a new simulation:

```{r}
## Creating a modifiers
increasing_modifier <- make.modifiers(branch.length = increasing.brlen)

## Generating a new tree with this modifier
set.seed(0)
increasing_tree <- treats(bd.params = bd_params,
                        stop.rule = stop_rule,
                        modifiers = increasing_modifier)
``` 

And we can visualise the difference between the resulting trees:

```{r}
par(mfrow = c(1,3))
plot(default_tree,    main = "Default modifier")
plot(modified_tree,   main = "Constant branch length\nmodifier")
plot(increasing_tree, main = "Increasing branch length\nmodifier (binned)")
par(mfrow = c(1,1))
```


## The selection function (`selection`)

The `selection` function is used in the birth-death process to know which lineage to select when running a speciation (or extinction!) event.
By default, this function randomly selects one taxon that is currently not extinct (using: `sample(1:lineage$n, 1))`.
Similarly to `branch.length`, it is possible to modify this part of the birth-death process.
For example, we could simply select the last created lineage to create a "ladder" or most asymmetric tree:

```{r}
## Our function to always select the last taxon
## (making sure it returns an integer)
select.last <- function(lineage) {
    return(as.integer(lineage$n))
}
```

> Note that here the function can only take the [allowed arguments as described above](#allowarguments) (here `lineage$n`: the number of current living taxa).

We can then create a `"modifiers"` object the same way as before this time using the `selection` argument:

```{r}
## A modifier for selection
ladderised_modifier <- make.modifiers(selection = select.last)
## Generating a new tree with this modifier
set.seed(0)
ladderised_tree <- treats(bd.params = bd_params,
                        stop.rule = stop_rule,
                        modifiers = ladderised_modifier)
## Displaying the results
par(mfrow = c(1,2))
plot(default_tree,    main = "Default modifier")
plot(ladderised_tree, main = "Ladderising modifier")
par(mfrow = c(1,1))
```

Again, it is of course possible to make the modifier more complex and in combination with other elements of the tree.
For example, we can create a `"treats"` object that also generates a BM trait and add to it this object a `selection` modifier that only selects tips with positive trait values (only species with positive trait values will speciate).

```{r}
## Our function that only select taxa with positive trait values
select.positive <- function(trait.values, lineage) {

    ## Selecting the taxa names with positive values for the first trait
    positives <- as.integer(rownames(trait.values)[which(trait.values[, 1] >= 0)])

    ## Combine the descendants of the current lineages (lineage$parents)
    ## with the species that have speciated (seq_along(lineages$split))
    ## to have a table of pairs of parents/splits
    parents_split_table <- cbind(lineage$parents, seq_along(lineage$split))
    ## Select the current taxa that descend from a node with a positive value
    positive_living <- parents_split_table[which(lineage$parents %in% positives), 2]

    ## Select one tip randomly in the ones with descendants with positive values
    return(sample(which(lineage$livings %in% positive_living), 1))
}

## Creating the modifier
positive_skew <- make.modifiers(selection = select.positive)

## Creating a (default) trait object
BM_trait <- make.traits()

## Simulate a tree and trait with no modifier
set.seed(1)
default_treats <- treats(bd.params = bd_params,
                     stop.rule = stop_rule,
                     traits = BM_trait)

## Simulate a tree and trait with the modifier
set.seed(1)
skewed_trait_treats <- treats(bd.params = bd_params,
                          stop.rule = stop_rule,
                          traits = BM_trait,
                          modifiers = positive_skew)

## Plotting the differences in trees and traits
par(mfrow = c(1, 2))
plot(default_treats, main = "Default trait and tree")
plot(skewed_trait_treats, main = "Skewed trait and tree")
```

## The speciation function (`speciation`)

The third function that can be used to modify the birth-death process is the `speciation` function.
This one is used during the birth-death process to decide whether a lineage speciates (creating a node and two new lineages) or goes extinct (creating a tip).

> Note that the `speciation` function only affects tips or nodes before the simulation reaches the `stop.rule`.
The then surviving lineages are all automatically transformed into tips.

By default, the `speciation` function is trigger a speciation even if a number randomly drawn from a uniform distribution is lower than the ratio between the speciation and the speciation and extinction parameter. If the randomly drawn number is higher, the lineage goes extinct.

```{r, eval = FALSE}
## The speciation in pseudo-code:
runif(1) < speciation/ (speciation + extinction)
```

Creating `"modifiers"` with a `speciation` function works the same way as for `branch.length` and `selection` but the function that will be used needs to output a logical value (see table [below](#summarymodifiers)).
Once the function is created simply input your function for speciation in the modifier and run the `treats` function with that modifier:

```{r, eval = FALSE}
## Speciating or going extinct randomly
## (regardless of the extinction parameter)
random.extinct  <- function() {
    return(sample(c(TRUE, FALSE), 1))
}

## Creating the modifiers object
random_extinction <- make.modifiers(speciation = random.extinct)

## Generating a new tree with this modifier
set.seed(2)
modified_tree <- treats(bd.params = bd_params,
                      stop.rule = stop_rule,
                      modifiers = random_extinction)

par(mfrow = c(1,2))
plot(default_tree,  main = "Default modifier")
plot(modified_tree, main = "Random extinction\nmodifier")
par(mfrow = c(1,1))
```

> Note how loads of lineages go extinct even if the extinction parameter is set to 0!

And again, we can make some more advanced modifiers: for example, one where a tip always goes extinct if their ancestor has a negative trait value. Here we will also introduce the utility function `parent.trait` that automatically selects the trait values of the parent of the current lineage.

```{r}
## A modifier for removing tips with negative values
modify.trait <- function(trait.values, lineage) {
    if(parent.traits(trait.values, lineage) < 0) {
        ## Go extinct!
        return(FALSE)
    } else {
        ## Speciate!
        return(TRUE)
    }
}

## Creating the modifier
modified_trait <- make.modifiers(speciation = modify.trait)

## Simulate a tree and trait with the modifier
set.seed(1)
modified_trait_treats <- treats(bd.params = bd_params,
                          stop.rule = stop_rule,
                          traits    = BM_trait,
                          modifiers = modified_trait)

## Plotting the differences in trees and traits
par(mfrow = c(1, 2))
plot(default_treats, main = "Default trait and tree")
plot(modified_trait_treats, main = "Biased trait and tree")
```

## Summary of the inputs and outputs for the `branch.length`, `selection` and `speciation` modifiers {#summarymodifiers}

modifier name   | accepted input (arguments) | required output (class) |
----------------|----------------------------|-------------------------|
`branch.length` | `bd.params`, `lineage`, `trait.values` | `"numeric"` |
`selection`     | `bd.params`, `lineage`, `trait.values` | `"integer"` |
`speciation`    | `bd.params`, `lineage`, `trait.values` | `"logical"` |

## The condition and modify functions (`condition` and `modify`)

In the examples above, we have seen how to specify modifications to the birth-death process (via `branch.length`, `selection` and `speciation`), however, these modifications are not dynamic.
In other words, throughout the process, the modifications remain constant (even if they are conditional).
It is however, possible to code the `"modifiers"` so that they can be affected by `"events"` objects (see next chapter [on `events`](#makeevents)).

To do so, you can formally declare conditions (`condition`) and modifications (`modify`) as internal functions that can then be modified by an `"events"` object.
`condition` and `modify` are hard coded in the `branch.length` function that they concern, i.e. they are variables (functions) within the function.

For example in the `speciation` part of a modifier, the default is to trigger an event from a uniform distribution and then check if that value is smaller than ($speciation/(speciation + extinction)$):

```{r}
## The default speciation algorithm
speciation <- function(bd.params) {
    ## Randomly trigger an event
    trigger_event <- runif(1)

    ## Speciate?
    return(trigger_event < (bd.params$speciation/
                              (bd.params$speciation + bd.params$extinction)))
}
```

It is possible with some specific conditions to modify this trigger by providing a `condition` and `modify` function to the speciation function.
That is, if the `condition` is met, apply the `modify` function to the algorithm.
For example here we can edit the default speciation function to have a modification (`modify = double.the.trigger`: doubling the trigger value) happening half the time (`condition = half.the.time`):

```{r}
## A conditional function that triggers half the time
half.the.time <- function() return(sample(c(TRUE, FALSE), 1))
## A modification that doubles the value to trigger the event
double.the.trigger <- function(x) return(x*2)
## A conditional modifier
make.modifiers(speciation = speciation,
               condition  = half.the.time, 
               modify = double.the.trigger)
```
Effectively, this will internally modify the speciation function as follows:

```{r, eval = FALSE}
## The default speciation algorithm
speciation <- function(bd.params) {
    ## Randomly trigger an event
    trigger_event <- runif(1)

    ## Modify the triggering
    if(half.the.time()) { ## This running the half.the.time function drawing TRUE or FALSE randomly
        trigger_event <- double.the.trigger(trigger_event) ## This will double the random value trigger_event
    }

    ## Speciate?
    return(trigger_event < (bd.params$speciation/
                              (bd.params$speciation + bd.params$extinction)))
}
```

These `condition` and `modify` functions can be applied to all the `modifiers` elements (`selection`, `branch.length` and `speciation`).
However, they are typically used in `events` that will modify the `modifiers` ([see the `events` section](#makeevents))!

<!--chapter:end:03_make.modifiers.Rmd-->

---
title: "`make.events`"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
bibliography: [../references.bib]
output:
  html_document: default
  pdf_document: default
---


```{r, echo = FALSE}
library(rgl)
knitr::knit_hooks$set(webgl = hook_webgl)
```

```{r, echo = FALSE}
library(treats)
set.seed(123)
```

# Adding events to simulations {#makeevents}

One other major feature of the `treats` package is that it allows simulations to run with specified events that occur during the simulation.
These are typically events that can drastically change the course of the simulation.
For example, you might want simulate a mass extinction at some specific point in time.
However, these can also be more subtle, like the internal change of parameter values when reaching a specific trait value.
These are all handled by `treats` with the `events` object that you can create using `make.events` and has the same overall logic as `make.traits` and `make.modifiers`.

`events` require three main arguments:
 * the `target` which designates what the extinction should affect (e.g. the taxa, the speciation rate, etc...);
 * the `condition` which designates when to trigger the event;
 * the `modification` which designates what to modify when the event is triggered.

There are several more arguments that can be passed to `make.events` but they are discussed later on.
First let's focus on these three main arguments:

![`make.events`: events are encoded using three main arguments: the `target`, specifying _what_ the event is modifying, the `condition` specifying _when_ to trigger the event, and `modification`, specifying _how_ the event modifies the simulations.](make.events.png)

### Quick overview


  condition,
  modification,
  add,
  test = TRUE,
  event.name,
  replications = 0,
  additional.args
)

function | arguments | input | what does it do
---------|-----------|-------|----------------
`make.events` | target* | any of the following: "taxa", "bd.params", "traits", "modifiers" or "founding" | what aspect of the simulation should the event target
`make.events` | condition* | a function | a function that affects the condition of when to trigger the event (see below)
`make.events` | modification* | a function | a function that applies the modification to the target if the condition is triggered (see below)
`make.events` | add | a `treats` object | another event generated by `make.events`
`make.events` | test | logical | whether to test the validity of the event
`make.events` | event.name | a character string | the name of the event
`make.events` | replications | a number | if possible how many times is the event allowing to be repeated
`make.events` | additional.args | ... | any additional arguments to be passed to the event


Here is a list of implemented `conditions` (see `?events.conditions`):

function | arguments | input | what does it do
---------|-----------|-------|----------------
`age.condition`, `taxa.condition`, `trait.condition` | x | the value to check the target against | e.g. time = x, taxa = x or trait = x (see below)
... | condition | a relational operator | e.g. `==`, `>`, `!=`, etc. for asking for example `time == x` 
... | ... | any additional arguments to be passed to the event | |

Here is a list of implemented `modifications` (see `?events.modifications`):

 function | arguments | input | what does it do
---------|-----------|-------|----------------
`random.extinction` | x | a numeric value | the proportion of species to make extinct
`trait.extinction` | x | a numeric value | the trait value when to trigger the extinction
`trait.extinction` | condition | a relational operator | the relation to the trait value (e.g. `x = 1` and `condition =  >` makes species that have a trait value > 1 go extinct)
`bd.params.update` | ... | any argument to be passed to `make.bd.params` | |
`traits.update` | ... | any argument to be passed to `make.traits` | |
`modifiers.update` | ... | any argument to be passed to `make.modifiers` | |

\* non-optional arguments

## Target

The target of the event is what the event is going to modify in the birth-death algorithm.
You can only have one target per event (along with one condition and one modification) but you can create events that contain multiple events (i.e. multiple triplets of target/condition/modification).
The targets that are currently available are:

 * `"taxa"` to modify anything linked to the [`lineage` list](#allowarguments). e.g. making half of the living taxa go extinct.
 * `"bd.params"` to modify anything linked to the [`bd.params` object](#makebdparams). For example you might want to change the distribution of one of the parameter after some `conditions`. This is typically done by updating the object using the argument `update` from `make.bd.params`.
 * `"traits"` to modify anything linked to the [`traits` object](#maketraits). For example you might want to change the trait process after some `conditions`. This is typically done by updating the object using the argument `update` from `make.traits`.
 * `"modifiers"` to modify anything linked to the [`modifiers` object](#makebdmodifiers). For example you might want to change the speciation rule after some `conditions`. This is typically done by updating the object using the argument `update` from `make.modifiers`.
 * `"founding"` this target is a bit more specialised and allows you run a nested `treats` object in the simulation. It is covered in a [specific section below](#founding).

We will see some examples of these targets in the `conditions` and `modifications` described below.

## Conditions

`condition` is a function that returns a logical value. When a specific condition is met, it should return `TRUE` and trigger the event, else it should return `FALSE`.

Currently there are three conditions functions implemented in `treats` but you can easily come up with your own version of them.

All `condition` functions in `treats` take at least two arguments: `x` for the variable of interest (e.g. time, number of taxa, trait value, etc.) and `condition`, the relational operator to evaluate. A relational operator is the proper (fancy) term designating all the comparisons you're regularly using in `R` like `==` (is equal?) `<` (is smaller?) `>=` (is bigger or equal?). You can get the full list in the R base manual (using `?Comparison` or any of the relational operator in a function form). For more details on how functions _really_ work in R see the [Advanced `R` book](https://adv-r.hadley.nz/functions.html)!

 * `age.condition` will trigger the `event` once a certain time is reached in the simulations and is the simplest/most basic condition with no arguments other than the time required. For example ``age.condition(4, condition = `==`)`` will trigger the `event` once the simulations reaches 4 time units. Easy.
 * `taxa.condition` will trigger the `event` once a certain number of taxa are reached. This can be considered including or excluding fossil species. For example ``taxa.condition(42, condition = `>=`, living = TRUE)`` will trigger the `event` if there are at least 42 living taxa.
 * `trait.condition` will trigger the `event` once a certain trait value is reached. This function allows to say which trait(s) to target (by default, the first one using `trait = 1`), what value of the trait to target (by default `what = max`) and whether to use and absolute trait value or not (`absolute = TRUE`). For example ``trait.condition(1/3, condition = `>`, trait = 1, what = sd)`` will trigger the condition after the standard deviation of the first trait reaches 1/3.

## Modifications

After defining the `event`, `target` and `condition`, you also need to specify what it should modify.
These are functions that should modify a specific aspect of the target.
Depending on the target you can modify the following:

 * if the target is `"taxa"` you can modify the internal [`lineage` list](#allowarguments) by removing living species using `random.extinction` or `trait.extinction`.
 * if the target is `"taxa"` you can modify the lineage tracker by removing living species using `random.extinction` or `trait.extinction`.
 * if the target is `"bd.params"` you can modify the [`bd.params` object](#makebdparams) using `bd.params.update`.
 * if the target is `"traits"` you can modify the [`traits` object](#maketraits) using `traits.update`.
 * if the target is `"modifiers"` you can modify the [`modifiers` object](#makemodifiers) using `modifiers.update`.
 * (for the `"founding"` target [see below](#founding))

The most straightforward example is for `modifications` on `bd.params`, `traits` or `modifiers` objects because they use the same syntax as for their generic `make.X` function.
For example, for `make.traits`, you can update a `trait` using the `update` argument as follows:

```{r}
## A BM trait in two dimensions
(BM_2D <- make.traits(n = 2, process = BM.process))
## Updating the 2D BM into a 2D OU
(OU_2D <- make.traits(update = BM_2D, process = OU.process))
```

So the function `update.X` applies the update to the object `X` when the event happens.
The following `event` updates the `bd.params` object by setting the extinction parameter to 1/3 when reaching a 10 species:

```{r, eval = FALSE}
make.events(target = "bd.params",
            condition = taxa.condition(10, condition = `>=`),
            modification = bd.params.update(extinction = 1/3))
```

> Note that by default events are triggered only once across the whole simulation, so although the example above states that the condition is reaching at least 10 taxa, it will not trigger every time it reaches more than 10 taxa, only the first time. You can change the number of times the events can be triggered using the argument `replications` (by default it's set to `replications = 0` for triggering the event only once).

## Examples

Here are some examples illustrating how to generate events.
For a simple example, we can create a extinction event that will remove 80% of species after reaching time 4:

```{r}
## 80% mass extinction at time 4
mass_extinction <- make.events(
                      target = "taxa",
                      condition = age.condition(4),
                      modification = random.extinction(0.8))

## Simulation parameters
stop.rule <- list(max.time = 5)
bd.params <- list(extinction = 0, speciation = 1)

## Running the simulations
set.seed(123)
results <- treats(bd.params = bd.params,
                stop.rule = stop.rule,
                events = mass_extinction)
## Plotting the results
plot(results, show.tip.label = FALSE)
axisPhylo()
```

Or for a slightly more complex example, we can can change the trait process from a BM to an OU when the trait values reaches an upper 95% quantile value above 2:

```{r}
## The 95% upper quantile value of a distribution
upper.95 <- function(x) {
    return(quantile(x, prob = 0.95))
} 
## Create an event to change the trait process
change_process <- make.events(
                  target = "traits",
                  ## condition is triggered if(upper.95(x) > 3)
                  condition = trait.condition(3, condition = `>`, what = upper.95),
                  modification = traits.update(process = OU.process))

## Set the simulation parameters
bd.params <- list(extinction = 0, speciation = 1)
stop.rule <- list(max.time = 6)
traits    <- make.traits()

## Run the simulations
set.seed(1)
no_change <- treats(bd.params = bd.params,
                  stop.rule = stop.rule,
                  traits = traits)
set.seed(1)
process_change <- treats(bd.params = bd.params,
                       stop.rule = stop.rule,
                       traits = traits,
                       events = change_process)
## Plot the results
par(mfrow = c(1,2))
plot(no_change, ylim = c(-7, 7))
plot(process_change, ylim = c(-7, 7))
par(mfrow = c(1,1))
```


## Founding events {#founding}

Founding events are a specific `target` for `events` that allows you to simulate a birth-death process within the current one!
It allows you to simulate a specific `treats` process using the `treats` function with its own `traits`, `modifiers`, `bd.params` and `events` (and yes, that's including `events` that have their own `founding` event).
This is basically the ultimate nested boss of modularity!

The founding event will run an internal `treats` process (i.e. simulating a tree and, optionally, some data) resulting in a founding sub-tree.
It will then branch this sub-tree onto the rest of the simulation that continued normally in the mean time.
You can specify the founding event using the inbuilt `founding.event` modification event.
This function takes the exact same arguments as `treats` to simulate the sub-tree with its own parameters.
Additionally, we will use the `additional.args` argument from `make.events` to specify a prefix for the founding tree tips (to make them easier to distinguish).

```{r}
## Set up parameters
stop.rule <- list(max.time = 4)
bd.params <- make.bd.params(speciation = 1, extinction = 0.3)

## Events that generate a new process (founding tree - with no extinction)
founding_event <- make.events(
                  target = "founding",
                  condition = taxa.condition(10),
                  modification = founding.event(
                                    bd.params = make.bd.params(speciation = 2,
                                                               extinction = 0)),
                  additional.args = list(prefix = "founding_"))
    
## Simulations
set.seed(11)
founding_tree <- treats(bd.params = bd.params,
                      stop.rule = stop.rule,
                      events = founding_event)
plot(founding_tree, cex = 0.4)
```

Note that the nestedness here is potentially endless, for example, you can pass an `event` argument to the `founding.event` that will generate another founding event, etc.

<!--chapter:end:04_make.events.Rmd-->

---
title: "`other functionalities`"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
bibliography: [../references.bib]
output:
  html_document: default
  pdf_document: default
---


```{r, echo = FALSE}
library(treats)
library(rgl)
knitr::knit_hooks$set(webgl = hook_webgl)
```

# Other functionalities {#others}

## `make.bd.params` {#makebdparams}

In most examples above, birth-death parameters were set as fixed values, i.e. a speciation rate of $\lambda$ and an extinction rate of $\mu$ throughout the simulations (with maybe some events modifying these rates).
However, it is possible to set these rates as specific or changing distributions. 
You can do this using the `make.bd.params` function to provide either a `vector` of values: 

```{r}
## An example where the speciation is randomly sampled among three values
my_bd_params <- make.bd.params(speciation = c(1/3,42))

## Building a tree using this set of parameters
set.seed(123)
plot(treats(stop.rule = list(max.taxa = 50), bd.params = my_bd_params))
## Note the regions in the tree with short branches
## (that's the speciation being 1/3 while the others are speciation = 42) 
```

Or to directly provide a function from which to sample:

```{r}
## Another example where speciation is drawn from the interval (0, 1)
make.bd.params(speciation = runif)
```

In this example, the `"bd.params"` object passed to the `treats` function will allow the birth-death process to sample the speciation parameter each time it is called (e.g. during the speciation/extinction step, the branch length step, etc.).
If using a function, you can fine tune the arguments to be passed to that function using the `speciation.args` or the `extinction.args` arguments (as a named list matching the function's arguments):

```{r}
## Speciation is drawn from the interval (0.5, 1.5)
make.bd.params(speciation = runif,
               speciation.args = list(min = 0.5, max = 1.5))
```

When using distributions for both the speciation and extinction parameters, you can run into the (usually) undesired problem of having an extinction rate that is higher than your speciation rate and thus all the taxa in your tree dying out.
You can avoid this problem by using the `joint` distribution argument. 
This will ensure that the sampling of the extinction rate is always lower or equal to the speciation rate.

```{r}
## Joint speciation and extinction sampled from uniform distribution 
## with speciation always >= to extinction
make.bd.params(speciation = runif, extinction = runif, joint = TRUE)
```

Finally to avoid negative sampling values, you can use the argument `absolute` that will make all the sampled values positive.
This argument is set to `TRUE` by default so you shouldn't have to worry about it most of the time unless you specifically need negative sampled values for your parameters.

```{r}
## Making the speciation sampling always positive
make.bd.params(speciation = rnorm, absolute = TRUE)
```

The two other possible arguments for this function are `test` and `update` that work the same way as [`make.traits`](#maketraits) or [`make.modifiers`](#makemodifiers)

If you are a visual person and your `bd.params` objects are getting a bit too complicated to remember, you can always quickly plot them. 
The function will sample from the `bd.params` object and show the results:

```{r}
par(mfrow = c(2,3))
plot(make.bd.params(), main = "Default birth-death parameters")
plot(make.bd.params(speciation = runif,
               speciation.args = list(min = 0.5, max = 1.5)),
     main = "Uniform speciation between 0.5 and 1.5\n(no extinction)")
plot(make.bd.params(speciation = runif,
                    speciation.args = list(min = 0.5, max = 1.5)),
     main = "Uniform speciation between 0.5 and 1.5\n(no extinction)")
plot(make.bd.params(speciation = runif, extinction = runif, joint = TRUE),
     main = "Joint uniform speciation and extinction")
plot(make.bd.params(speciation = rnorm, extinction = runif,
                    joint = FALSE, abs = FALSE),
     main = "Disjoint normal speciation and uniform extinction")
par(mfrow = c(1,1))
```


## `drop.things` {#dropthings}

You can use the function `drop.things` to drop specific elements of the tree and data at the same time by providing the argument `what = "fossils"` for tips that went extinct, or `what = "livings"` for tips that where alive at the end of the simulation or `what = "singles"` to drop internal singleton nodes.
Alternatively you can use the function aliases `drop.fossils`, `drop.livings` or `drop.singles` for the exact same results:

```{r}
## A random tree with fossils and traits and internal nodes every 0.5 times
set.seed(3)
my_data <- treats(stop.rule = list(max.taxa = 20),
                bd.params = list(speciation = 1, extinction = 1/3),
                traits    = make.traits(), save.steps = 0.5)

## A tree with 20 tips and 54 nodes
my_data$tree
## And a dataset with 74 rows
dim(my_data$data)

## Removing the fossil species
drop.things(my_data, what = "fossils")$tree
dim(drop.fossils(my_data)$data)

## Removing the living species
drop.things(my_data, what = "livings")$tree
dim(drop.livings(my_data)$data)

## Removing the internal nodes
drop.things(my_data, what = "singles")$tree
dim(drop.singles(my_data)$data)

## Removing the internal nodes AND the fossils
drop.singles(drop.fossils(my_data))
```

## `"treats"` internal utilities

The package also provides utilities for internal functions, namely for designing `modifiers` or `events` more easily.
These functions don't do anything useful on their own but are optimised to be used internally in `treats`.
For all these functions, you can look at the internal manual for an example (i.e. using `?<function_name>`)

So far the package has the following internals:

Function  | What it does | Where can it be used
----------|--------------|---------------------
`parent.traits` | selects the trait values of the current lineage's parents (i.e. direct ancestor) | in `make.modifiers`
`taxa.condition` | provides a trigger for an `event` dependent on the number of taxa | in `make.events`
`age.condition` | provides a trigger for an `event` dependent on time | in `make.events`
`trait.condition` | provides a trigger for an `event` dependent on trait values | in `make.events`

<!--chapter:end:05_other_functionalities.Rmd-->

---
title: "`plot.treats`"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
# bibliography: [../References.bib, ../packages.bib]
output:
  html_document: default
  pdf_document: default
---

```{r, echo = FALSE}
library(treats)
library(rgl)
knitr::knit_hooks$set(webgl = hook_webgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
```

# Plots

`"treats"` objects can be directly plotted in `treats` using the S3 `plot.treats` function (or just `plot(x)` if `x` is of class `"treats"`).

## Plotting traits

`"treats"` `"traits"` objects are covered in the [traits section](#maketraits).
You can use `plot.treats` to plot them by choosing which specific trait to plot using the `trait` argument (default is 1):

```{r, fig.height=8, fig.width=8}
## Making a list of three traits
list_of_traits <- make.traits(process = c(no.process, BM.process, OU.process), trait.names = c("No process (normal)", "Brownian motion", "Ornstein-Uhlenbeck"))
## Plotting each trait separately
par(mfrow = c(2, 2))
plot(list_of_traits, trait = 1)
## Using different colours options
plot(list_of_traits, trait = 2, col = c("red", "purple", "pink"))
## Not using the default plot name
plot(list_of_traits, trait = 3, main = "OU process",
     cent.tend = sd, quantiles = c(10, 30))
par(mfrow = c(1, 1))
```

You can also control the number of replicates in the simulation by using the `simulations` option (the default is 50).
Bigger numbers lead to more time but smoother looking plots while smaller ones are more stochastic:

```{r, fig.width=6, fig.height=12}
par(mfrow = c(2,1))
plot(list_of_traits, trait = 2, simulations = 10, main = "10 BM simulations")
plot(list_of_traits, trait = 2, simulations = 1000, main = "1k BM simulations")
par(mfrow = c(1,1))
```


## Plotting `treats` results

If `treats` is used to plot only a tree (and outputs a `"phylo"` object), you can use the function `plot.phylo` from the `ape` package to plot your tree.
You'll find all the tree plotting options in the `?plot.phylo` manual page.

```{r}
## A simple pure birth tree
my_tree <- treats(stop.rule = list(max.taxa = 20))
plot(my_tree, main = "Plotting a \"phylo\" object")
```

However, if you also simulated a trait along with the tree you can use the `plot.treats` function to plot both the tree and the trait:

```{r}
## A simple pure birth tree with a BM process
my_tree <- treats(stop.rule = list(max.taxa = 20), traits = make.traits())
## Playing with the default options
plot(my_tree, main = "A tree and traits")
```

By default, elements are coloured as follows: nodes and tips are points and coloured in blue if they are tips (light blue if they are fossils) and nodes are in orange.
Branches linking them are grey lines.
You can of course change this colour palette to whatever you prefer by calling the standard base R arguments that can be passed to `points` or `lines`. For example `pch` for the point type or `lty` for the line type.
Furthermore, time is plotted conventionally from left to right (left is towards the past, right is towards the present) but you can change that by specifying `xlim`.


```{r, fig.height = 6, fig.width = 6}
## Playing with some more options
plot(my_tree, main = "A tree and traits",
     ## Changing nodes colours and type
     col = c(tips = "pink", nodes = "purple"), pch = 21,
     ## Changing edge colour and type
     lwd = 2, lty = 3, edges = "yellow",
     ## Changing the x axis orientation and label
     xlim = c(0, 2.5), xlab = "Time into the past")
```

> Note that in `plot.treats` you can modify colours using the `col` argument by providing a clear indication of what you want to colour (e.g. `col = c(tips = "blue", fossils = "orange")` will apply the colours to the unambiguously named elements) or by providing a function that will scale the colours with time (e.g. `col = grDevices::heat.colors` will use the specified function to change the  colours of the elements through time).

You can add a default legend by using `legend = TRUE` (if you don't want to add the default legend you can add it after your plot using `legend(...)`).

```{r, fig.height = 6, fig.width = 6}
## Adding the default legend
plot(my_tree, legend = TRUE)
```

### Adding dimensions! Not necessary, but fun!

Of course, if you're simulating multiple traits, you can always plot different ones.

```{r, fig.height = 6, fig.width = 6}
## Specifying a 3D trait process
my_3D_trait <- make.traits(n = 3, )
## Simulating a birth-death tree with that 3D trait
my_data <- treats(bd.params = list(extinction = 0.2),
                stop.rule = list(max.living = 50),
                traits    = my_3D_trait)
```

You can toggle which trait to plot using the `trait` option, either by providing a single value to plot that specific trait against time or by providing two traits.

```{r, fig.height = 12, fig.width = 6}
par(mfrow = c(2,1))
## Plotting the second trait
plot(my_data, trait = 2, main = "Trait 2")
## Plotting the correlation between trait 1 and 2
plot(my_data, trait = c(1,2), main = "Traits 1 and 2")
```

As mentioned above, the `col` argument can take a function for scaling the elements colours with time.
This can be useful for adding time a third dimension to these 2D plots:

```{r}
## Plotting the correlation between trait 1 and 2
## with time as a 3rd dimensions
plot(my_data, trait = c(1,2), main = "Traits 1 and 2",
     col = grDevices::heat.colors, legend = TRUE,
     ## Highlighting the tips in black for visibility
     tips.nodes = "black")
```

But there's more! You can also plot these results using actual 3D plots that you can spin and all that!
This is done through the `rgl` package and activated in `treats` using the option `use.3D = TRUE`.

If two traits are provided, the 3rd dimension is going to be time by default:

```{r}
## Plotting the tree and 2 traits in 3D: woah!
plot(my_data, trait = c(1, 2), use.3D = TRUE)
rglwidget()
```

If three traits are provide, you can set up a fourth coloured dimension as time (similarly to the 2D plots with the colour gradients).
This uses the `rgl` functions, namely `lines3d`, `points3d` (if `type = "p"`; default) or `sphere3d` (if `type = "s"`).
The additional arguments `...` are directly handled and attributed to the corresponding function.

```{r}
## Plotting the tree and 3 traits in 3D
plot(my_data, trait = c(1, 2, 3), use.3D = TRUE,
     col = grDevices::heat.colors, type = "s", radius = 0.1)
rglwidget()
```

<!--chapter:end:06_plotting_dads_objects.Rmd-->

---
title: "treats manual"
author: "Thomas Guillerme (guillert@tcd.ie)"
date: "`r Sys.Date()`"
# bibliography: [../References.bib, ../packages.bib]
output:
  html_document: default
  pdf_document: default
---

# Specific examples


```{r, echo = FALSE}
library(treats)
library(rgl)
knitr::knit_hooks$set(webgl = hook_webgl)
options(rgl.useNULL = TRUE) # Suppress the separate window.
```

In this section I will illustrate a series of examples of specific more complex scenarios.
They can be all run independently and used as a basis for your own specific scenarios.

Here is a table summarising which functionalities are used in which example:

Functionality showcase | Example
--------------|---------
`bd.params` | [reducing speciation rate](#EGred_spec), [generating a subtree with no extinction](#EG_founding_purebirth)
`make.events` | [mass extinction](#EGrandom_ext), [negative trait extinction](#EGneg_ext), [background extinction](#EGbg_ext), [reducing speciation rate](#EGred_spec), [changing trait process](#EG_change_trait), [changing trait correlation](#EG_change_correlation), [changing modifiers](#EG_change_modif), [change branch length](#EG_modify_brlen), [generating a subtree with no extinction](#EG_founding_purebirth), [generating a subtree with a different process](EG_founding_traits)
`make.traits` | [negative trait extinction](#EGneg_ext), [changing trait process](#EG_change_trait), [changing trait correlation](#EG_change_correlation), [generating a subtree with a different process](EG_founding_traits)
`make.modifiers` | [changing modifiers](#EG_change_modif), [change branch length](#EG_modify_brlen)

And more specifically for the events:

Functionality showcase | Example
--------------|----------
`age.condition` | [mass extinction](#EGrandom_ext), [negative trait extinction](#EGneg_ext), [reducing speciation rate](#EGred_spec), [changing trait process](#EG_change_trait), [changing modifiers](#EG_change_modif)
`random.extinction` | [mass extinction](#EGrandom_ext)
`trait.extinction` | [negative trait extinction](#EGneg_ext)
`taxa.condition` | [background extinction](#EGbg_ext), [change branch length](#EG_modify_brlen)
`bd.params.update` | [background extinction](#EGbg_ext), [reducing speciation rate](#EGred_spec)
`traits.update` | [changing trait process](#EG_change_trait), [changing trait correlation](#EG_change_correlation)
`trait.condition` | [changing trait correlation](#EG_change_correlation), [generating a subtree with a different process](EG_founding_traits)
`modifiers.update` | [changing modifiers](#EG_change_modif), [change branch length](#EG_modify_brlen)
`parent.traits` | [changing modifiers](#EG_change_modif)
`founding.event` | [generating a subtree with no extinction](#EG_founding_purebirth), [generating a subtree with a different process](EG_founding_traits)


<!-- TODO add a recursive event example where discrete self rate is changed by half everytime you reach 10 living species -->



## Random mass extinction after some time {#EGrandom_ext}

For this scenario, we want to generate a pure birth tree (no traits and no extinction) where 80% of the species go extinct two thirds of the way into the scenario.

For that we first need to first set our simulation parameters: we will be running the simulation for 6 time units and with a speciation rate of 1 (and extinction of 0 - default).

```{r}
## Setting the parameters
stop_time_6 <- list(max.time = 6)
speciation_1 <- make.bd.params(speciation = 1)
```

We will then create a event that triggers when reaching half of the simulation time (using `age.condition(2.5)`).
This event will target `"taxa"`, i.e. the number of species, and randomly remove 80% of them (using `random.extinction(0.8)`):

```{r}
## 80% mass extinction at time 4
mass.extinction <- make.events(
                    condition = age.condition(4),
                    target = "taxa",
                    modification = random.extinction(0.8))
```

Once these parameters are defined, we can run the simulations and plot the results:

```{r}
## Running the simulations
set.seed(1)
results <- treats(stop.rule = stop_time_6,
                bd.params = speciation_1,
                events    = mass.extinction)
## Plotting the results
plot(results, show.tip.label = FALSE)
axisPhylo()
```

## Species with negative trait values go extinct after a certain time {#EGneg_ext}

For this scenario, we want to generate a pure birth tree with a one dimensional Brownian Motion trait for 5 time units.
We then want species with a negative trait value go extinct after 4 time units.

First we need to set up the simulation parameters:
 * The stopping rule (5 time units)
 * The birth-death parameters (speciation rate of 1)

```{r}
## Simulation parameters
stop_time_5 <- list(max.time = 5)
speciation_1 <- make.bd.params(speciation = 1)
```

Then set up our trait which is a one dimensional Brownian Motion

```{r}
## Trait
simple_bm_trait <- make.traits(n = 1, process = BM.process)
```

And our extinction event which triggers after reaching time 4 (`age.condition(4)`), targets the `"taxa"` and modifies the extinction for species with traits lower than 0.

```{r}
## Extinction of any tips with trait < 1 at time 4
trait.extinction <- make.events(
                      target = "taxa",
                      condition = age.condition(4),
                      modification = trait.extinction(x = 0,
                                                      condition = `<`))
```

Once these parameters are defined, we can run the simulations and plot the results:

```{r}
## Running the simulations
set.seed(7)
results <- treats(stop.rule = stop_time_5,
                bd.params = speciation_1,
                traits    = simple_bm_trait,
                events    = trait.extinction)
## Plotting the results
plot(results)
```

## Adding a background extinction after reaching a number of living taxa {#EGbg_ext}

For this scenario, we want to generate a pure birth tree until reaching 50 living taxa but with an extinction rate appearing after reaching 30 taxa.

First we need to set up the simulation parameters:
 * The stopping rule (50 taxa max)
 * The birth-death parameters (speciation rate of 1)

```{r}
## Simulation parameters
stop_taxa_50 <- list(max.living = 50)
speciation_1 <- make.bd.params(speciation = 1)
```

And our change in extinction rate event which triggers after reaching 30 taxa (`taxa.condition(30)`), targets the `"bd.params"` (birth-death parameters) sets the extinction rate to 0.5 (`bd.params.update(extinction = 0.5)`):

```{r}
## Adding an extinction parameter after 30 taxa
background.extinction <- make.events(
                      condition = taxa.condition(30),
                      target = "bd.params",
                      modification = bd.params.update(extinction = 0.5))
```

Once these parameters are defined, we can run the simulations and plot the results:

```{r}
## Running the simulations
set.seed(2)
results <- treats(stop.rule = stop_taxa_50,
                bd.params = speciation_1,
                events = background.extinction)
## Plotting the results
plot(results, show.tip.label = FALSE)
```

## Reducing speciation rate after a certain time {#EGred_spec}

For this scenario, we want to generate a birth tree for 6 times units with random speciation rates (i.e. drawn from a uniform (0.5;1) distribution) which reduces after time 4 through the simulations to a fixed value of 1/3.

First we need to set up the simulation parameters:
 * The stopping rule (6 time units)
 * The birth-death parameters (speciation randomly drawn between 0.5 and 1)

```{r}
## Simulation parameters
stop_time_6 <- list(max.time = 6)
random_speciation <- make.bd.params(speciation = runif, 
                                    speciation.args = list(min = 0.5, max = 1))
```

And our extinction event which triggers after reaching time 4 (`age.condition(4)`), targets the `"bd.params"` and modifies the speciation rate to 1/3:

```{r}
## Reducing speciation after reaching time 4
reduced.speciation <- make.events(
                      condition = age.condition(4),
                      target = "bd.params",
                      modification = bd.params.update(speciation = 1/3))
```

Once these parameters are defined, we can run the simulations and plot the results.
We can contrast the results with the scenario without an event (but same random seed):

```{r}
## No event
set.seed(42)
no_event <- treats(stop.rule = stop_time_6,
                 bd.params = random_speciation)

## Reduced speciation event
set.seed(42)
reduced_speciation_event <- treats(stop.rule = stop_time_6,
                                 bd.params = random_speciation,
                                 events = reduced.speciation)

## Plot both trees
par(mfrow = c(1, 2))
plot(no_event, main = "No event", show.tip.label = FALSE)
axisPhylo()
plot(reduced_speciation_event, 
     main = "Reduced speciation after time 5", 
     show.tip.label = FALSE)
axisPhylo()
```

## Changing the trait process after some time {#EG_change_trait}

For this scenario, we want to generate a pure birth tree with a one dimensional Brownian Motion trait for 5 time units which then changes to an OU process.

First we need to set up the simulation parameters:
 * The stopping rule (6 time units)
 * The birth-death parameters (speciation rate of 1)

```{r}
## Simulation parameters
stop_time_6 <- list(max.time = 6)
speciation_1 <- make.bd.params(speciation = 1)
```

Then set up our trait which is a one dimensional Brownian Motion

```{r}
## Trait
simple_bm_trait <- make.traits(n = 1, process = BM.process)
```

And our event which triggers after reaching time 5 (`age.condition(5)`), targets the `"traits"` and modifies the process to `OU.process`.

```{r}
## Create an event to change the trait process
change.process.to.OU <- make.events(
                  condition    = age.condition(5),
                  target       = "traits",
                  modification = traits.update(process = OU.process))
```

Once these parameters are defined, we can run the simulations and plot the results.
We can contrast the results with the scenario without an event (but same random seed):

```{r}
## Run the simulations without change
set.seed(1)
no_change <- treats(stop.rule = stop_time_6,
                  bd.params = speciation_1,
                  traits    = simple_bm_trait)
## Run the simulations with change
set.seed(1)
process_change <- treats(stop.rule = stop_time_6,
                       bd.params = speciation_1,
                       traits    = simple_bm_trait,
                       events    = change.process.to.OU)
## Plot the results
par(mfrow = c(1,2))
plot(no_change, ylim = c(-7, 7))
plot(process_change, ylim = c(-7, 7))
```

## Changing trait correlation after reaching a trait value {#EG_change_correlation}


For this scenario, we want to generate a pure birth tree with a 2 dimensional Brownian Motion trait with a strict correlation between the two dimensions (1:1) that loosen up when a taxa reaches an absolute value of 2.

First we need to set up the simulation parameters:
 * The stopping rule (100 taxa)
 * The birth-death parameters (speciation rate of 1)

```{r}
## Set the parameters
stop_taxa_100 <- list(max.taxa = 100)
speciation_1 <- make.bd.params(speciation = 1)
```

Then set up our trait which is a 2 dimensional Brownian Motion with a correlation matrix Sigma ()

```{r}
## A 2D variance covariance matrix
cor_matrix <- matrix(1, 2, 2)

## A correlated 2D Brownian Motion
correlated_2D_BM <- make.traits(n = 2, process = BM.process,
                      process.args = list(Sigma = cor_matrix))
```

And our event which triggers after a taxa gets the trait value 3 (`trait.condition(3, absolute = TRUE)`), targets the `"traits"` and modifies the traits correlation

```{r}
## New correlation
new_cor <- matrix(c(10,3,3,2),2,2)

## Event changing a trait correlation
correlation.change <- make.events(
    condition    = trait.condition(3, absolute = TRUE),
    target       = "traits",
    modification = traits.update(process.args = list(Sigma = new_cor)))
```

Once these parameters are defined, we can run the simulations and plot the results.
We can contrast the results with the scenario without an event (but same random seed):

```{r}
## Run the simulations
set.seed(2)
no_event <- treats(stop.rule = stop_taxa_100,
                 bd.params = speciation_1,
                 traits    = correlated_2D_BM)
set.seed(2)
change_correlation <- treats(stop.rule = stop_taxa_100,
                           bd.params = speciation_1,
                           traits    = correlated_2D_BM,
                           events    = correlation.change)

## Visual testing
par(mfrow = c(1,2))
plot(no_event, trait = c(1,2), main = "Strict correlation")
plot(change_correlation, trait = c(1,2), main = "Loosened correlation")
```

And we can visualise this change through time:

```{r}
## 3D plot
plot(change_correlation, trait = c(1:2), use.3D = TRUE)
rglwidget()
```

## Event for changing a modifier: extinction event increase for species with negative values {#EG_change_modif}

For this scenario, we want to generate a pure birth tree with a one dimensional Brownian Motion trait for 4 time units.
After 3 time units, we want the speciation rule to increase for species which ancestors have a negative trait value.

First we need to set up the simulation parameters:
 * The stopping rule (5 time units)
 * The birth-death parameters (speciation rate of 1)

```{r}
## Set the parameters
stop_time_4 <- list(max.time = 4)
speciation_1 <- make.bd.params(speciation = 1)
```

Then set up our trait which is a one dimensional Brownian Motion

```{r}
## Trait
simple_bm_trait <- make.traits(n = 1, process = BM.process)
```

And a modifier that is the default birth-death algorithm rules

```{r}
## birth-death rules (default)
default_modifiers <- make.modifiers()
```

And our extinction event which triggers after reaching time 3 (`age.condition(3)`), targets the `"modifiers"` and modifies birth-death rule as follows:
 * When a species is descendant from a parent with a negative trait value (`negative.trait.condition`);
 * Then increase your chances of going extinct by +1 (`increase.extinction.1`)

```{r}
## New condition and new modifier (increasing speciation if trait is negative)
negative.trait.condition <- function(trait.values, lineage) {
    return(parent.traits(trait.values, lineage) < 0)
}
increase.extinction.1 <- function(x, trait.values, lineage) {
  return(x + 1)
}

## Update the modifier
change.speciation <- make.events(
    condition    = age.condition(3),
    target       = "modifiers",
    modification = modifiers.update(speciation = speciation,
                                    condition  = negative.trait.condition,
                                    modify     = increase.extinction.1))
```

Once these parameters are defined, we can run the simulations and plot the results.
We can contrast the results with the scenario without an event (but same random seed):

```{r}
set.seed(4)
no_event <- treats(stop.rule = stop_time_4,
                 bd.params = speciation_1,
                 traits    = simple_bm_trait,
                 modifiers = default_modifiers)
set.seed(4)
change_spec <- treats(stop.rule = stop_time_4,
                    bd.params = speciation_1,
                    traits    = simple_bm_trait,
                    modifiers = default_modifiers,
                    events    = change.speciation)

## Visualise the results
par(mfrow = c(1,2))
plot(no_event, main = "No event")
plot(change_spec, main = "Increase extinction for negative\ntraits after time 3")
```

## Changing branch length when reaching n taxa {#EG_modify_brlen}

For this scenario, we want to generate a pure birth tree until reaching 100 taxa.
After reaching 30 taxa we want branch length growth to increase 50 folds.

First we need to set up the simulation parameters:
 * The stopping rule (100 taxa)
 * The birth-death parameters (speciation rate of 1)

```{r}
## Set the parameters
stop_taxa_100<- list(max.taxa = 100)
speciation_1 <- make.bd.params(speciation = 1)
```

Then a modifier that is the default birth-death algorithm rules

```{r}
## birth-death rules (default)
default_modifiers <- make.modifiers()
```

And event which triggers after reaching 30 taxa (`taxa.condition(30)`), targets the `"modifiers"` and modifies the branch length generation rule to a 50 fold increase (`increase.50.folds`)

```{r}
## Multiplying branch length 50 folds
increase.50.folds <- function(x, trait.values, lineage) {
  return(x * 50)
}
## Event for increasing branch length after reaching 30 taxa
increase_brlen <- make.events(
                  condition = taxa.condition(30),
                  target = "modifiers",
                  modification = modifiers.update(
                                    branch.length = branch.length,
                                    modify  = increase.50.folds))
```

Once these parameters are defined, we can run the simulations and plot the results.
We can contrast the results with the scenario without an event (but same random seed):

```{r}
## Run the simulations
set.seed(5)
no_event <- treats(stop.rule = stop_taxa_100,
                 bd.params = speciation_1,
                 modifiers = default_modifiers)
set.seed(5)
increased_brlen <- treats(stop.rule = stop_taxa_100,
                        bd.params = speciation_1,
                        modifiers = default_modifiers,
                        events = increase_brlen)

## Visualise the results
par(mfrow = c(1,2))
plot(no_event, main = "No event", show.tip.label = FALSE)
plot(increased_brlen, main = "Increase branch length\nafter 30 taxa",
    show.tip.label = FALSE)
```

## Founding event: generating a subtree with no fossils {#EG_founding_purebirth}

For this scenario, we want to generate a birth-death tree for 4 time units.
After reaching 10 taxa, one random taxa will give birth to a sub-tree that is a pure birth tree (no extinction).

First we need to set up the simulation parameters:
 * The stopping rule (5 time units)
 * The birth-death parameters (speciation rate of 1 and extinction of 0.2)

```{r}
## Set up parameters
stop_time_4 <- list(max.time = 4)
spec_1_ext_02 <- make.bd.params(speciation = 1, extinction = 0.2)
```

And our event which triggers after reaching 10 taxa (`taxa.condition(10)`), and generates a subtree ("founding") that is a pure birth tree (no extinction and speciation rate of 2).

```{r}
## Setting the pure-birth parameters
speciation_2 <- make.bd.params(speciation = 2)

## Events that generate a new process (founding effects)
founding_event <- make.events(
                  condition = taxa.condition(10),
                  target  = "founding",
                  modification = founding.event(
                                    bd.params = speciation_2),
                  additional.args = list(prefix = "founding_"))
```

> Note we are prodviding an additional argument `prefix` here so that we can track which species are part of the sub tree for colouring them down the line.

Once these parameters are defined, we can run the simulations and plot the results:

```{r}    
## Simulations
set.seed(11)
founding_tree <- treats(stop.rule = stop_time_4,
                      bd.params = spec_1_ext_02,
                      events = founding_event)

## Selecting the edges colours
tip_values <- rep("black", Ntip(founding_tree))
tip_values[grep("founding_", founding_tree$tip.label)] <- "orange"
edge_colors <- match.tip.edge(tip_values, founding_tree, replace.na = "black")

## Plotting the results
plot(founding_tree, show.tip.label = FALSE, edge.color = edge_colors)
```

## Founding event: generating a subtree a different process {#EG_founding_traits}

For this scenario, we want to generate a birth-death tree with a one dimensional Brownian Motion trait for 6 time units.
After a taxon reaches the value 3 or higher, it gives birth to a sub-tree that generates an OU trait with a long-term mean at the value 3.

First we need to set up the simulation parameters:
 * The stopping rule (6 time units)
 * The birth-death parameters (speciation rate of 1 and extinction of 1/3)

```{r}
## The tree parameters
stop_time_6 <- list(max.time = 6)
speciation_1_extinction_03 <- make.bd.params(speciation = 1,
                                             extinction = 0.3)
```

Then set up our trait which is a one dimensional Brownian Motion

```{r}
## Trait
simple_bm_trait <- make.traits(n = 1, process = BM.process)
```

When a taxa reaches the value 3 `trait.condition`, it generates a pure birth tree (`speciation = 2`) with an OU trait with the long-term mean value 3.

```{r}
## The OU trait with a long-term mean value of 3
OU_3 <- make.traits(process = OU.process,
                    start = 3, process.args = list(optimum = 3))
## The pure birth parameters
speciation_2 <- make.bd.params(speciation = 2)

## The founding event
new_OU_trait <- make.events(
                    condition    = trait.condition(3, condition = `>=`),
                    target       = "founding",
                    modification = founding.event(
                                    bd.params = speciation_2,
                                    traits    = OU_3))
```

Once these parameters are defined, we can run the simulations and plot the results:

```{r}
## Simulating the tree
set.seed(1)
founding_tree <- treats(stop.rule = stop_time_6,
                      bd.params = speciation_1_extinction_03,
                      traits = simple_bm_trait,
                      events = new_OU_trait)
plot(founding_tree)
```

<!--chapter:end:07_specific_examples.Rmd-->

